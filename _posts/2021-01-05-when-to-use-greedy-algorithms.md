---
layout: post
title: "탐욕스러운 알고리즘 사용 시기 - 방지 시기 [예제 문제]"
author: 'Code Tower'
thumbnail: https://images.unsplash.com/photo-1572193727388-723406836820?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDR8fGdyZWVkfGVufDB8fHw&ixlib=rb-1.2.1&q=80&w=2000
tags: undefined
---


탐욕스러운 알고리듬은 모든 단계에서 사용 가능한 최상의 선택을 통해 최적의 솔루션을 찾으려고 한다.

예를 들어, 여러분은 탐욕스럽게 여러분의 삶에 접근할 수 있습니다. 당신은 항상 오늘 당신의 행복을 극대화하는 길을 택할 수 있습니다. 하지만 그렇다고 내일이 더 행복해지는 건 아니에요.

마찬가지로, 탐욕 알고리듬이 최상의 해결책을 제시하지 못하는 문제가 있다. 사실, 그들은 최악의 해결책을 제시할 수도 있습니다.

그러나 탐욕스러운 전략을 사용함으로써 충분히 좋은 해결책을 얻을 수 있는 다른 사례도 있습니다.

이 기사에서는 최적의 솔루션을 찾는다는 보장이 되지 않을 때에도 탐욕스러운 알고리즘과 이 전략의 사용에 대해 쓰겠습니다.

첫 번째 섹션은 이 전략을 사용하여 해결할 수 있는 탐욕스러운 알고리듬과 잘 알려진 문제에 대한 소개이다. 그럼 욕심쟁이 전략이 정말 나쁜 선택인 문제에 대해 이야기하겠습니다. 마지막으로, 탐욕스러운 알고리즘을 통해 근사치의 예를 보여드리겠습니다.

> 참고: 이 기사에서 논의하는 알고리즘과 문제의 대부분은 그래프입니다. 이 게시물을 최대한 활용할 수 있도록 그래프에 익숙하시면 좋을 것 같습니다.

## 그리디 알고리즘의 작동 방식

그리디 알고리즘은 항상 사용 가능한 최상의 옵션을 선택합니다.

일반적으로 동적 프로그래밍 또는 브루트 포스와 같은 알고리듬 계열보다 계산적으로 저렴하다. 이는 그들이 솔루션 공간을 너무 많이 탐색하지 않기 때문입니다. 그리고, 같은 이유로, 그들은 많은 문제에 대한 최선의 해결책을 찾지 못합니다.

하지만 탐욕스러운 전략으로 해결할 수 있는 많은 문제들이 있습니다. 그리고 그러한 전략들은 정확히 최선의 방법입니다.

가장 인기 있는 탐욕 알고리듬 중 하나는 그래프에서 한 꼭짓점에서 다른 꼭짓점까지의 최소 비용을 가진 경로를 찾는 Dijkstra의 알고리듬이다.

이 알고리즘은 항상 가장 가까운 꼭짓점으로 이동하여 그러한 경로를 찾는다. 그것이 우리가 그것이 탐욕스러운 알고리즘이라고 말하는 이유이다.

알고리즘에 대한 유사 코드입니다. 나는 그래프 G와 소스 노드를 각각 s로 나타낸다.

```undefined
Dijkstra(G, s):
    distances <- list of length equal to the number of nodes of the graph, initially it has all its elements equal to infinite

    distances[s] = 0

    queue = the set of vertices of G

    while queue is not empty:

          u <- vertex in queue with min distances[u]

          remove u from queue

          for each neighbor v of u:
              temp = distances[u] + value(u,v)

              if temp < distances[v]:
                   distances[v] = temp
     return distances

```

이 알고리즘을 실행한 후, 우리는 거리[u]가 노드 `s`에서 노드 `u`로 가는 최소 비용인 `distance` 목록을 얻는다.

이 알고리즘은 그래프에서 음의 비용을 가진 에지가 없는 경우에만 작동할 수 있습니다. 가장자리에 음의 비용이 들 경우 탐욕스러운 전략이 최적이 아닌 경로를 선택하게 될 수 있습니다.

탐욕스러운 전략의 개념을 도입하는 데 사용되는 또 다른 예는 분수 배낭이다.

이 문제에서, 우리는 아이템을 수집했습니다. 각 품목의 가중치 `위`가 0보다 크고 이익 `파이`도 0보다 크다.

우리는 `W` 용량의 배낭을 가지고 있으며 최대한의 이익을 얻을 수 있는 방법으로 배낭을 메우고 싶습니다. 물론 배낭의 용량을 초과할 수는 없습니다.

배낭 문제의 부분 버전에서는 전체 개체 또는 그 중 일부만 취할 수 있다. i번째 물체의 부분 `0 = X = 1`을 취하면 `X*Pi`와 같은 이익을 얻으며 가방에 `X*Wi`를 추가해야 한다.

우리는 탐욕스러운 전략을 사용하여 이 문제를 해결할 수 있습니다. 저는 여기서 해결책을 논의하지 않겠습니다. 잘 모르면 혼자서 해결한 다음 온라인으로 해결 방법을 찾아보는 것을 추천합니다.

탐욕스러운 알고리즘을 사용해서 해결할 수 있는 문제들의 수는 엄청나다. 하지만 우리가 이런 식으로 해결할 수 없는 문제들의 수는 훨씬 더 큽니다. 다음 섹션은 후자의 문제에 관한 것이다 - 우리가 이런 식으로 해결해서는 안 되는 문제들.

## 욕심을 부릴 때가 가장 나쁘다.

이전 섹션에서, 우리는 탐욕스러운 전략을 사용하여 해결할 수 있는 문제의 두 가지 예를 보았다. 이것은 매우 빠른 알고리즘이기 때문에 좋습니다.

하지만, 제가 말했듯이, Dijkstra의 알고리즘은 음의 모서리가 있는 그래프에서는 작동하지 않습니다.

그리고 문제는 훨씬 더 크다. 나는 항상 내가 원하는 만큼 Dijkstra의 솔루션이 나쁠 수 있도록 음의 모서리를 가진 그래프를 만들 수 있다! 스택 오버플로에서 추출한 다음 예를 고려하십시오.

다이크스트라의 알고리즘은 A와 C 사이의 거리를 찾지 못한다. -200일 때 "d(A, C) = 0"을 찾습니다. 그리고 에지 `D -> B`의 값을 줄이면 실제 최소 거리보다 훨씬 더 먼 거리를 얻을 수 있습니다.

마찬가지로, 배낭 문제(0-1 배낭 문제)에서 객체를 분해할 수 없을 때, 탐욕스러운 전략을 사용할 때 얻는 솔루션도 상당히 나쁠 수 있다. 우리는 항상 탐욕 알고리듬이 심하게 실패하게 만드는 문제에 대한 입력을 구축할 수 있다.

또 다른 예로 TSP(Traveling Salesman Problem)가 있습니다. 도시 목록과 각 도시 쌍 사이의 거리를 고려할 때, 각 도시를 정확히 한 번 방문하고 출발 도시로 돌아오는 가장 짧은 경로는 무엇인가?

우리는 항상 가능한 가장 가까운 도시로 가는 것으로 그 문제에 탐욕스럽게 접근할 수 있다. 우리는 어떤 도시든 첫 번째 도시로 선정하고 그 전략을 적용합니다.

앞의 예에서와 같이, 탐욕스러운 전략이 가능한 최악의 해결책을 찾는 방식으로 우리는 항상 도시들의 기질을 구축할 수 있다.

이 섹션에서는 탐욕스러운 전략이 우리를 재앙으로 이끌 수 있다는 것을 보았습니다. 그러나 그러한 접근 방식이 최적의 해결책과 상당히 근접할 수 있는 문제가 있다.

## 욕심을 부릴 때가 그렇게 나쁘지는 않다.

우리는 탐욕스러운 전략이 몇 가지 문제에 대해 우리가 원하는 만큼 나빠질 수 있다는 것을 보아왔다. 이것은 우리가 최적의 해결책이나 심지어 그것의 좋은 근사치를 얻기 위해 그것을 사용할 수 없다는 것을 의미한다.

그러나 탐욕스러운 알고리즘이 우리에게 매우 좋은 근사치를 제공하는 몇 가지 예가 있다. 이러한 경우, 탐욕스러운 접근 방식은 더 저렴하고 구현하기 쉬운 경향이 있기 때문에 매우 유용하다.

그래프의 정점 커버는 그래프의 모든 가장자리가 집합에 적어도 하나의 끝점을 갖도록 하는 최소 정점 집합입니다.

이것은 매우 어려운 문제입니다. 사실, 그것에 대한 효율적이고 정확한 해결책은 없어. 하지만 좋은 소식은 탐욕스러운 알고리즘으로 좋은 근사치를 만들 수 있다는 것입니다.

그래프에서 u, v를 선택하고 집합에 u와 v를 추가합니다. 그런 다음 끝점 중 하나로 `u` 또는 `v`가 있는 모든 가장자리를 제거하고 나머지 그래프가 가장자리를 갖는 동안 이전 프로세스를 반복한다.

이전 알고리즘의 유사 코드일 수 있습니다.

```undefined
vertexCover(G):
    VertexCover <- {} // empty set
    E' <- edges of G

    while E' is not empty:
          VertexCover <- VertexCover U {u,v} where <u,v> is in E'
          E' = E' - {<u, v> U edges incident to u, v}

     return VertexCover

```

보시다시피, 이것은 간단하고 비교적 빠른 알고리즘입니다. 하지만 가장 좋은 점은 솔루션이 항상 최적의 솔루션보다 2배 이하가 된다는 것입니다. 입력 그래프가 어떻게 작성되었든 간에, 우리는 더 작은 꼭짓점 커버의 두 배보다 더 큰 세트를 결코 얻지 못할 것이다.

이 게시물에 이 문장의 데모를 포함시키지는 않겠지만, 꼭짓점 커버에 추가하는 모든 가장자리 `u, v`에 대해 `u` 또는 `v`가 최적의 솔루션(즉, 더 작은 꼭짓점 커버에)에 있다는 것을 알게 되면 그것을 증명할 수 있다.

많은 컴퓨터 과학자들은 이러한 근사치들을 더 찾기 위해 노력하고 있다. 더 많은 예들이 있지만, 저는 여기서 멈추려고 합니다.

이것은 컴퓨터 과학과 응용 수학에서 흥미롭고 매우 활발한 연구 분야입니다. 이러한 근사치로, 우리는 매우 간단한 알고리듬을 구현함으로써 매우 어려운 문제에 대한 매우 좋은 해결책을 얻을 수 있다.

## 결론들

이 게시물에서는 탐욕스러운 알고리즘에 대해 간략하게 소개했습니다. 탐욕스러운 전략으로 해결할 수 있는 문제들의 예를 보았습니다. 그런 다음, 탐욕스러운 전략이 나쁜 선택인 몇 가지 문제에 대해 이야기합니다. 마지막으로, 어려운 문제에 대한 근사한 해결책을 얻을 수 있는 탐욕스러운 알고리즘의 예를 보았습니다.

때로는 탐욕스러운 접근법으로 문제를 해결할 수 있지만 올바른 전략을 짜기는 어렵다. 그리고 (정확하거나 근사한 솔루션에 대한) 탐욕 알고리듬의 정확성을 입증하는 것은 매우 어려울 수 있다. 그래서, 탐욕스러운 알고리즘에 대해 우리가 논의할 수 있는 많은 것들이 있습니다!

만약 당신이 이 게시물을 즐겼고 내가 이런 종류의 콘텐츠를 계속 제공하기를 원한다면, 그것을 공유하고 태그를 붙여서 나에게 알려줘. 당신은 또한 더 많은 CS 관련 콘텐츠를 위해 트위터에서 나를 팔로우 할 수 있습니다.