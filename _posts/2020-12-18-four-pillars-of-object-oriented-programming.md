---
layout: post
title: "객체지향 프로그래밍의 4대 축"
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2020/12/The-four-pillars-of-object-orientation.png
tags: undefined
---


자바스크립트(JavaScript)는 다중 패러다임 언어이며 다른 프로그래밍 패러다임 뒤에 쓸 수 있다. 프로그래밍 패러다임은 기본적으로 코드를 작성할 때 특정 문제를 해결하는 데 도움이 되는 여러 가지 규칙입니다.

그것이 바로 네 개의 기둥입니다. 이는 깨끗한 객체 지향 코드를 작성하는 데 도움이 되는 소프트웨어 설계 원리입니다.

객체 지향 프로그래밍의 네 가지 요소는 다음과 같습니다.

- 추상화
- 캡슐화
- 상속
- 다형성

각각에 대해 자세히 알아보도록 하죠.

어떤 것을 추상화한다는 것은 어떤 것의 내부에 구현 세부 사항, 때로는 프로토타입, 때로는 기능을 숨기는 것을 의미합니다. 따라서 함수를 호출할 때 정확히 무엇을 하는지 이해할 필요가 없습니다.

빅 코드베이스의 모든 기능을 이해해야 한다면 어떤 것도 코드화할 수 없습니다. 이 모든 것을 다 읽는 데는 몇 달이 걸릴 것이다.

특정 세부 정보를 추상화하여 재사용 가능하고 이해하기 쉬우며 쉽게 변경할 수 있는 코드베이스를 만들 수 있습니다. 예를 들어 보겠습니다.

이 예제에서 사용자 정의 사용 사례에 필요한 사항을 정확히 구현해야 하는 방법을 볼 수 있습니까?

당신이 쳐야 하는 모든 새로운 API는 새로운 "if" 블록이 필요하고 그것은 고유의 사용자 지정 코드이다. 새로 추가할 모든 유형의 구현에 대해 걱정할 필요가 있으므로 이 방법은 추상화되지 않습니다. 재사용이 불가능하며 유지 보수에 대한 악몽입니다.

아래와 같은 것은 어떻습니까?

```js
hitApi('www.kealanparr.com', HTTPMethod.Get)
```

이제 기능 및 사용할 HTTP 메서드에 URL을 전달하기만 하면 됩니다.

기능이 어떻게 작동되는지 걱정할 필요가 없습니다. 다 해결됐어요. 이는 코드 재사용에 크게 도움이 됩니다! 그리고 코드를 훨씬 더 쉽게 유지할 수 있게 해줍니다.

그것이 바로 추상화의 전부이다. 코드에서 유사한 것을 찾고 여러 곳에 서비스를 제공하는 일반적인 기능 또는 개체를 제공합니다.

여기 추상화의 좋은 마지막 예가 있습니다: 사용자들을 위해 커피를 만드는 기계를 만든다고 상상해 보십시오. 두 가지 접근방식이 있을 수 있습니다.

## 추상화를 사용하여 만드는 방법

- "커피 만들기"라는 제목의 단추를 가져라.

## 추상화 없이 만드는 방법

- "물을 끓여라"라는 제목의 단추를 가져라.
- "주전자에 찬물 넣기"라는 제목의 단추를 가져라.
- "깨끗한 컵에 갈린 커피 1스푼 추가"라는 제목의 버튼을 누릅니다.
- "더러운 컵 청소"라는 제목의 버튼을 누릅니다.
- 그리고 다른 모든 버튼들

이것은 매우 간단한 예이지만, 첫 번째 접근 방식은 기계 안에 있는 논리를 추상화합니다. 그러나 두 번째 접근 방식은 사용자가 커피를 만드는 방법을 이해하고 본질적으로 자신만의 커피를 만들도록 강요한다.

다음 기둥은 캡슐화를 사용하여 추상화를 달성할 수 있는 한 가지 방법을 보여줍니다.

캡슐화의 정의는 "캡슐 안에 또는 캡슐에 있는 것처럼 무언가를 둘러싸는 행위"이다. 코드 일부에 대한 액세스를 제거하고 사물을 비공개로 만드는 것이 바로 캡슐화의 핵심입니다(대개 사람들은 이를 데이터 숨기기라고 부릅니다).

캡슐화는 코드의 각 개체가 자체 상태를 제어해야 함을 의미합니다. 상태는 개체의 현재 "스냅샷"입니다. 키, 객체의 메서드, 부울 속성 등이 있습니다. 부울을 재설정하거나 개체에서 키를 삭제하려면 해당 키가 모두 사용자의 상태로 변경됩니다.

코드 조각에 액세스할 수 있는 범위를 제한합니다. 필요하지 않은 경우 더 많은 항목에 액세스할 수 없도록 합니다.

비공개 속성은 폐쇄를 사용하여 JavaScript에서 달성됩니다. 아래 예는 다음과 같습니다.

```js
var Dog = (function () {

 // Private
 var play = function () {
  // play implementation
 };
    
 // Private
 var breed = "Dalmatian"
    
 // Public
 var name = "Rex";

 // Public
 var makeNoise = function () {
   return 'Bark bark!';
 };

  return {
  makeNoise: makeNoise,
  name: name
  };
})();


```

첫 번째 작업은 즉시 호출되는 함수(즉시 호출된 함수 식 또는 줄여서 IIFE)를 생성하는 것이었습니다. 이렇게 하면 누구나 액세스할 수 있는 개체가 만들어졌지만 일부 세부 정보는 숨겼습니다. 재생을 부를 수도 없고, 반환과 함께 최종 객체에 노출되지 않았기 때문에 사육에 접근할 수도 없습니다.

위의 특정 패턴은 노출 모듈 패턴이라고 합니다. 그러나 이는 캡슐화를 달성하는 방법을 보여주는 예입니다.

나는 캡슐화 아이디어에 더 초점을 맞추고 싶다. (단 하나의 패턴을 학습하고 캡슐화를 현재 완전히 완료된 것으로 계산하는 것보다 더 중요하기 때문이다.

반영하고 데이터와 코드를 숨기고 분리하는 방법에 대해 더 생각해 보십시오. 모듈화 및 명확한 책임 보유는 객체 지향의 핵심입니다.

왜 우리는 프라이버시를 선호해야 하는가? 왜 모든 것을 글로벌화하지 않는가?

- 관련 없는 많은 코드 비트는 전역 변수를 통해 서로 종속되거나 결합됩니다.
- 이름이 재사용될 경우 변수를 재정의할 수 있으며, 이로 인해 버그나 예측 불가능한 동작이 발생할 수 있습니다.
- 스파게티 코드 - 변수를 읽고 쓰는 것과 변화하는 상태를 추론하고 따르기가 어려운 코드로 끝날 가능성이 높습니다.

캡슐화는 긴 줄의 코드를 더 작은 개별 기능으로 분리함으로써 적용될 수 있다. 이러한 기능을 모듈로 구분하십시오. 우리는 다른 어떤 것도 접근할 필요가 없는 장소에 데이터를 숨기고, 필요한 것을 깨끗하게 노출시킵니다.

그것은 캡슐화이다. 클래스, 객체, 모듈 또는 기능 등 데이터에 바인딩하고 가능한 한 비공개로 유지하기 위해 최선을 다합니다.

상속을 통해 한 개체가 다른 개체의 속성 및 메서드를 얻을 수 있습니다. 자바스크립트에서 이것은 프로토타입팔 상속에서 이루어진다.

재사용이 여기서 주된 이점입니다. 우리는 때때로 여러 곳이 같은 일을 해야 한다는 것을 알고 있습니다. 그리고 그들은 하나의 작은 부분을 제외한 모든 것을 똑같이 해야 합니다. 이것은 상속이 해결할 수 있는 문제입니다.

상속을 이용할 때마다 부모와 자녀가 높은 응집력을 갖도록 노력합니다. 응집력은 당신의 코드가 얼마나 관련이 있는가이다. 예를 들어 `버드` 유형이 `디젤 엔진` 유형에서 확장됩니까?

상속을 쉽게 이해하고 예측할 수 있도록 유지하십시오. 당신이 필요로 하는 한 가지 방법이나 재산이 있기 때문에 전혀 관련이 없는 곳에서 상속하지 마세요. 상속이 그 특정한 문제를 잘 해결해주지 못한다.

상속을 사용할 때는 대부분의 기능을 요구해야 합니다(항상 모든 것이 절대적으로 필요한 것은 아님).

개발자들은 리스코프 대체 원칙이라고 불리는 원칙을 가지고 있다. 아이를 사용하는 곳에서는 부모 클래스(자녀 유형이라고 함)를 사용할 수 있고(자녀 유형이라고 함) 자녀 유형은 부모 유형에서 상속할 수 있으면 테스트에 합격한다고 명시되어 있습니다.

이 테스트에 실패한 주된 이유는 `차일드 유형`이 부모로부터 항목을 제거하는 경우입니다. ChildType이 부모로부터 상속받은 메서드를 제거하면 예상하지 못한 항목이 정의되지 않은 TypeError로 이어질 수 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/image-146.png)

상속 체인은 기본 개체의 프로토타입(다른 모든 것이 상속하는 것)에서 상속 체인의 "끝"으로 이어지는 상속의 흐름을 설명하는 데 사용되는 용어이다.

유산의 사슬을 깨끗하고 합리적으로 유지하기 위해 최선을 다하세요. 상속을 사용할 때 안티패턴(취약성 베이스 안티패턴)을 쉽게 코딩할 수 있습니다. 기본 프로토타입을 "안전하게" 변경한 다음 모든 자녀를 깨기 시작하기 때문에 기본 프로토타입을 "파손하기 쉬운" 것으로 간주할 때 이런 현상이 발생합니다.

다형성은 "여러 가지 다른 형태로 일어나는 조건"을 의미한다. 이것이 바로 네 번째이자 마지막 요소인 동일한 상속 사슬의 유형들이 서로 다른 일을 할 수 있는 것에 관한 것입니다.

상속을 올바르게 사용했다면 이제 자녀와 같은 부모를 신뢰할 수 있게 사용할 수 있습니다. 두 유형이 상속 체인을 공유하는 경우 코드에서 오류나 주장 없이 상호 교환하여 사용할 수 있습니다.

마지막 도표에서, 우리는 `make Noise`를 정의하는 `동물`이라고 불리는 기본 프로토타입을 가질 수 있다. 그러면 프로토타입에서 확장되는 모든 유형이 재정의되어 사용자 지정 작업을 수행할 수 있습니다. 이와 비슷한 것:

```js
// Let's set up an Animal and Dog example
function Animal(){}
function Dog(){}

Animal.prototype.makeNoise = function(){
 console.log("Base noise");
};

// Most animals we code up have 4. This can be overridden if needed
Animal.prototype.legs = 4;

Dog.prototype = new Animal();

Dog.prototype.makeNoise = function(){
 console.log("Woof woof");  
};

var animal = new Animal();
var dog = new Dog();

animal.makeNoise(); // Base noise
dog.makeNoise();    // Woof woof- this was overridden
dog.legs;           // 4! This was inherited
```

개는 애니멀(Animal)에서 확장돼 기본 다리(legs) 특성을 활용할 수 있다. 하지만 스스로 소음을 내는 구현도 할 수 있습니다.

다형성의 진정한 힘은 행동을 공유하고, 사용자 정의 재정의를 허용하는 것이다.

객체 지향 프로그래밍의 4대 축이 무엇인지, 그리고 그것들이 어떻게 더 깨끗하고 견고한 코드로 이어지는지를 설명해주었기를 바란다.

만약 당신이 이 기사를 즐기고 더 보고 싶다면 나는 트위터에 나의 글을 공유한다.