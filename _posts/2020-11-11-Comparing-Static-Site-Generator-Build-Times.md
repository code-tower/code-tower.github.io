---
layout: post
title: "정적 사이트 생성기 빌드 시간 비교"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/10/ssg-logo-tiles.png
tags: ELEVENTY,GATSBY,HUGO,JEKYLL,NEXT.JS,NUXT,STATIC SITE GENERATORS
---


정적 사이트 생성기 (SSG)가 너무 많습니다.
 어디서부터 시작해야할지 결정하는 것은 압도적입니다.
 많은 유용한 기사가 (인기) 옵션을 통과하는 데 도움이 될 수 있지만 마술처럼 쉽게 결정을 내리지는 못합니다.
 

저는 그 결정을 더 쉽게 할 수 있도록 돕기 위해 노력해 왔습니다.
 제 동료가 정적 사이트 생성기 평가 치트 시트를 만들었습니다.
 수많은 인기있는 SSG 선택에 대해 정말 멋진 스냅 샷을 제공합니다.
 빠진 것은 실제로 어떻게 작동하는지입니다.
 

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/10/ssg-comparison-cheatsheet.png?resize=3699%2C1332&ssl=1)

모든 정적 사이트 생성기의 공통된 기능 중 하나는 입력 데이터를 가져와 템플릿 엔진을 통해 실행하고 HTML 파일을 출력한다는 것입니다.
 일반적으로이 프로세스를 빌드라고합니다.
 

스프레드 시트에 표시하기 위해 빌드 프로세스 동안 다양한 SSG가 수행하는 방식을 비교하는 데 필요한 미묘한 차이, 컨텍스트 및 가변성이 너무 많으므로 인기있는 정적 사이트 생성기와 비교하여 빌드 시간을 벤치 마크하기위한 테스트를 시작합니다.
 

이것은 단지 어떤 SSG가 가장 빠른지 결정하기위한 것이 아닙니다.
 Hugo는 이미 그 명성을 가지고 있습니다.
 내 말은, 그들은 그들의 웹 사이트 (웹 사이트 구축을위한 세계에서 가장 빠른 프레임 워크)에 그것을 말하고 있기 때문에 그것이 사실이어야합니다!
 

이것은 여러 인기 SSG의 빌드 시간을 심층적으로 비교 한 것이며, 더 중요한 것은 빌드 시간이 왜 그렇게 보이는지 분석하는 것입니다.
 맹목적으로 가장 빠른 것을 선택하거나 가장 느린 것을 불신하는 것은 실수입니다.
 이유를 알아 봅시다.
 

### 테스트
 

테스트 프로세스는 몇 개의 인기있는 SSG와 간단한 데이터 형식으로 간단하게 시작하도록 설계되었습니다.
 더 많은 SSG와 더 미묘한 데이터로 확장 할 수있는 기반입니다.
 오늘의 테스트에는 6 개의 인기있는 SSG 선택이 포함됩니다.
 

- Eleventy
 
- 개츠비
 
- 휴고
 
- 지킬
 
- 다음
 verified_user
- Nuxt
 

각 테스트는 다음 접근 방식과 조건을 사용했습니다.
 

- 각 빌드의 데이터 소스는 무작위로 생성 된 제목 (frontmatter)과 본문 (콘텐츠의 세 단락 포함)이있는 Markdown 파일입니다.
 
- 콘텐츠에 이미지가 없습니다.
 
- 테스트는 단일 기계에서 직렬로 실행되므로 실제 값은 로트 간의 상대적 비교보다 덜 관련성이 있습니다.
 
- 출력은 HTML 페이지의 일반 텍스트로, 시작에 대한 각 SSG의 각 가이드에 따라 기본 스타터를 통해 실행됩니다.
 
- 각 테스트는 콜드 실행입니다.
 캐시가 지워지고 Markdown 파일이 모든 테스트에 대해 다시 생성됩니다.
 

이러한 테스트는 벤치 마크 테스트로 간주됩니다.
 기본 마크 다운 파일을 사용하고 스타일이 지정되지 않은 HTML을 빌드 된 출력으로 출력합니다.
 

즉, 실제 시나리오는 아니지만 출력은 기술적으로 프로덕션에 배포 할 수있는 웹 사이트입니다.
 대신 이는 이러한 프레임 워크 간의 기준 비교를 제공합니다.
 이러한 프레임 워크 중 하나를 사용하여 개발자가 선택하면 다양한 방식으로 빌드 시간이 조정됩니다 (일반적으로 속도를 늦춤).
 

예를 들어 이것이 실제 환경을 나타내지 않는 한 가지 방법은 콜드 빌드를 테스트하는 것입니다.
 실제로 데이터 소스로 10,000 개의 Markdown 파일이 있고 Gatsby를 사용하는 경우 Gatsby의 캐시를 사용하여 빌드 시간을 크게 줄일 수 있습니다 (최대 절반까지).
 

변경된 파일 만 빌드한다는 점에서 웜 및 콜드 실행과 관련된 증분 빌드의 경우에도 마찬가지입니다.
 이 테스트에서는 점진적 접근 방식을 테스트하지 않습니다 (현재).
 

그러기 전에 먼저 정적 사이트 생성기의 두 계층이 실제로 있다는 것을 고려해 보겠습니다.
 기본 및 고급이라고 부르겠습니다.
 

- 기본 생성기는 기본적으로 데이터를 가져와 HTML을 출력하는 명령 줄 인터페이스 (CLI)이며 종종 자산을 처리하도록 확장 할 수 있습니다 (여기서는 설명하지 않음).
 
- 고급 생성기는 서버 측 렌더링, 서버리스 기능 및 프레임 워크 통합과 같은 정적 사이트 출력 외에도 무언가를 제공합니다.
 상자에서 꺼내 자마자 더 동적으로 구성되는 경향이 있습니다.
 

이 테스트에서 의도적으로 각 유형의 발전기 3 개를 선택했습니다.
 기본 버킷에 빠지는 것은 Eleventy, Hugo 및 Jekyll입니다.
 나머지 세 개는 프런트 엔드 프레임 워크를 기반으로하며 다양한 도구와 함께 제공됩니다.
 Gatsby와 Next는 React를 기반으로하고 Nuxt는 Vue를 기반으로합니다.
 

### 내 가설
 

과학은 재미 있고 유용하기 때문에이 접근 방식에 과학적 방법을 적용 해 보겠습니다!
 

내 가설은 SSG가 고급이면 기본 SSG보다 느리게 수행된다는 것입니다.
 고급 SSG는 기본 SSG보다 오버 헤드가 더 많기 때문에 결과가 반영 될 것이라고 생각합니다.
 따라서 기본 생성기와 고급 생성기의 두 그룹이 함께 번들로 묶여서 기본 생성기가 훨씬 더 빠르게 이동하는 결과를 볼 수 있습니다.
 

그 가설을 조금 확장 해 보겠습니다.
 

Hugo와 Eleventy는 더 작은 데이터 세트로 날아갈 것입니다.
 Go 및 Node.js의 (상대적으로) 간단한 프로세스이며 빌드 출력에이를 반영합니다.
 파일 수가 증가함에 따라 두 SSG가 느려질 것이지만, Go가 Node보다 성능이 더 높은 경향이 있기 때문에 Eleventy가 규모에서 약간 덜 선형적일 수 있지만 클래스의 최상위에 머물 것으로 기대합니다.
 

고급 또는 프레임 워크 바운드 SSG가 시작되고 느리게 나타납니다.
 단일 파일 테스트에는 Gatsby, Next 및 Nuxt의 경우 몇 초에 비해 기본 테스트의 경우 밀리 초라는 상당한 차이가있는 것으로 의심됩니다.
 

프레임 워크 기반 SSG는 각각 웹팩을 사용하여 빌드되므로 처리중인 콘텐츠의 양에 관계없이 상당한 양의 오버 헤드가 발생합니다.
 이것이 바로 이러한 도구를 사용하여 등록한 수하물입니다 (이 내용은 나중에 자세히 설명합니다).
 

그러나 수천 개의 파일을 추가하면 고급 SSG 그룹이 상당한 양만큼 뒤처 질 것이지만 버킷 간의 간격이 가까워 질 것이라고 생각합니다.
 

고급 SSG 그룹에서는 걱정할 서버 측 구성 요소가 없기 때문에 Gatsby가 가장 빠를 것으로 예상합니다. 그러나 그것은 단지 직감입니다.
 Next와 Nuxt는이 기능을 사용하지 않는 경우 빌드 시간에 영향을 미치지 않을 정도로 최적화했을 수 있습니다.
 그리고 Nuxt가 Next를 이길 것이라고 생각합니다. Vue에 대한 오버 헤드가 React에 비해 약간 적기 때문입니다.
 

루비는 매우 느립니다.
 시간이 지남에 따라 성능이 향상되었지만 Node와 함께 확장 될 것으로 예상하지 않으며 Go에서는 그렇지 않습니다.
 그러나 동시에 프레임 워크의 짐이 없습니다.
 

처음에는 Jekyll이 꽤 빠르며 Eleventy와 구별 할 수 없을 것입니다.
 그러나 수천 개의 파일에 도달하면 성능이 저하됩니다.
 내 직감은 지킬이 6 개 중 가장 느려지는 지점이있을 수 있다는 것입니다.
 확실히 확인하기 위해 100,000 점까지 올릴 것입니다.
 

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/10/jekyll-hand-chart.jpg?resize=1094%2C872&ssl=1)

### 결과가 나왔습니다!
 

이러한 테스트를 지원하는 코드는 GitHub에 있습니다.
 상대적인 결과를 보여주는 사이트도 있습니다.
 

이러한 테스트를 실행할 수있는 기반을 구축하는 여러 번의 반복 끝에 저는 세 가지 다른 데이터 세트에서 일련의 10 회 실행으로 끝났습니다.
 

- 기본 : 기본 빌드 시간을 비교하기위한 단일 파일
 
- 소규모 사이트 : 1 ~ 1024 개의 파일, 시간에 따라 두 배씩 증가 (SSG가 선형 적으로 확장되었는지 쉽게 확인할 수 있도록)
 
- 대규모 사이트 : 1,000 개에서 64,000 개 파일, 실행할 때마다 두 배씩.
 원래는 최대 128,000 개의 파일로 이동하고 싶었지만 몇 가지 프레임 워크에서 병목 현상이 발생했습니다.
 64,000은 플레이어가 더 큰 사이트에서 어떻게 확장 할 것인지에 대한 아이디어를 생성하기에 충분했습니다.
 

이미지를 클릭하거나 탭하면 더 크게 볼 수 있습니다.
 

### 결과 요약
 

몇 가지 결과는 나에게 놀랐고 다른 결과는 예상되었습니다.
 다음은 높은 수준의 요점입니다.
 

- 예상대로 휴고는 크기에 관계없이 가장 빠릅니다.
 내가 예상하지 못했던 것은 기본 빌드에서도 다른 생성기에 가깝지 않다는 것입니다.
 
- SSG의 기본 및 고급 그룹은 소규모 사이트의 결과를 볼 때 매우 분명합니다.
 예상 한대로 였지만 Next와 Eleventy가 64,000 개의 파일에서 가까워지는 것을 보는 것은 놀랍습니다.
 또한 놀랍게도 Jekyll은 모든 실행에서 Eleventy보다 빠르게 수행했습니다.
 
- 나는 Gatsby가 고급 프레임 워크 중에서 가장 빠르다고 생각했고 기본에 더 가까워 질 것이라고 생각했습니다.
 그러나 Gatsby는 가장 느린 것으로 밝혀졌으며 가장 극적인 곡선을 생성했습니다.
 
- 가설에서 구체적으로 언급되지 않았지만, 차이의 규모는 제가 상상했던 것보다 컸습니다.
 한 파일에서 Hugo는 Gatsby보다 약 250 배 더 빠릅니다.
 그러나 64,000 개의 파일에서 더 가깝습니다. 약 40 배 더 빠릅니다.
 즉, Hugo는 가장 빠르지 만 (상당히) 사이트 크기가 커질수록 시간이 다른 발전기에 더 가까워집니다.
 

이러한 SSG의 제작자 및 유지 관리자와 결과를 공유했을 때 일반적으로 동일한 메시지를 받았습니다.
 의역하기 :
 

> 빌드하는 데 더 많은 시간이 걸리는 발전기는 더 많은 일을하기 때문에 그렇게합니다.
 개발자가 작업 할 수있는 테이블에 더 많은 것을 제공하는 반면, 더 빠른 사이트 (즉, "기본"도구)는 템플릿을 HTML 파일로 변환하는 데 주로 집중합니다.
 

나는 동의한다.
 verified_user

요약하자면 Jamstack 사이트를 확장하는 것은 어렵습니다.
 

사이트를 확장 할 때 개발자 인 개발자에게 제시되는 과제는 구축하려는 사이트에 따라 다릅니다.
 이 데이터는 캡처 할 수 없기 때문에 여기에서 캡처되지 않습니다. 모든 프로젝트는 어떤면에서 고유합니다.
 

실제로 내려 오는 것은 개발자 경험을 대신하여 기다리는 것에 대한 관용 수준입니다.
 

예를 들어, Gatsby를 사용하여 이미지가 많은 대규모 사이트를 구축하려는 경우 구축 시간에 따라 비용을 지불해야하지만 엄청난 플러그인 네트워크와 구축 기반이 제공됩니다.
 견고하고 체계적인 구성 요소 기반 웹 사이트.
 Jekyll에서도 동일하게 수행하면 빌드가 더 빠르게 실행될 수 있지만 프로세스 전반에 걸쳐 체계적이고 효율적으로 유지하려면 훨씬 더 많은 노력이 필요합니다.
 

직장에서는 일반적으로 Gatsby (또는 필요한 동적 상호 작용 수준에 따라 Next)로 사이트를 구축합니다.
 우리는 Gatsby 프레임 워크와 협력하여 풍부한 구성 요소로 가득 찬 고도로 사용자 정의되고 이미지가 풍부한 웹 사이트를 빠르게 구축 할 수있는 핵심을 구축했습니다.
 사이트 규모가 커짐에 따라 빌드 속도가 느려지지만 마이크로 프런트 엔드 구현, 이미지 처리 오프로드, 콘텐츠 미리보기 구현, 기타 많은 최적화를 통해 창의력을 발휘할 수 있습니다.
 

한편으로는 Eleventy와 함께 일하는 것을 선호하는 경향이 있습니다.
 일반적으로 코드를 작성하는 것은 나 뿐이며 필요는 훨씬 간단합니다.
 (저는 제 자신을 좋은 클라이언트라고 생각하고 싶습니다.) 출력 파일을 더 잘 제어 할 수있어서 클라이언트 측 성능에 대한 💯를 더 쉽게 얻을 수 있다고 생각합니다.이 점이 제게 중요합니다.
 

결국 이것은 빠르거나 느린 것에 관한 것이 아닙니다.
 자신에게 가장 적합한 것이 무엇인지, 얼마나 오래 기다릴 것인지에 관한 것입니다.
 

### 마무리
 verified_user

이것은 시작에 불과합니다!
 이 노력의 목표는 인기있는 정적 사이트 생성기에서 상대적인 빌드 시간을 함께 벤치마킹 할 수있는 기반을 만드는 것이 었습니다.
 

어떤 아이디어가 있습니까?
 그 과정에서 어떤 구멍을 뚫을 수 있습니까?
 이러한 테스트를 강화하기 위해 무엇을 할 수 있습니까?
 어떻게하면 실제 시나리오처럼 만들 수 있습니까?
 처리를 전용 머신으로 오프로드해야합니까?
 

제가 답변하는 데 도움이 되었으면하는 질문입니다.
 그것에 대해 이야기합시다.
 