---
layout: post
title: "Python의 메모화, 재귀 및 루프에 대한 설명"
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2021/01/martin-shreder-5Xwaj9gaR0g-unsplash.jpg
tags: undefined
---


> 할 수 있는 방법은 한 가지가 아닙니다. 항상 다른 관점과 투구 스타일이 있다. 팀 허드슨

이 기사에서는 파이썬에서 세 가지 다른 기술을 사용하여 시퀀스의 합을 결과적으로 제공하는 기본 피보나치 프로그램을 코드화할 것이다. 피보나치 순서는 0,1,2,3,5,8...

눈치챘겠지만, 우리는 첫 번째 숫자와 두 번째 숫자인 0과 1을 더해서 순서 (1) -> 0+1=1에서 세 번째 숫자를 얻습니다. 그런 다음 두 번째 숫자와 세 번째 숫자인 1+1=2를 더하면 네 번째 숫자가 나옵니다.기타 등등.

이 코드는 주피터, 콜라브 또는 사용자가 편안하게 느끼는 모든 IDE 또는 텍스트 편집기에서 구현할 수 있습니다.

## 파이썬에서 포 루프를 사용하여 피보나치 시퀀스를 코드화하는 방법

여기 파이썬에서 a for roop을 사용하는 피보나치 기본 프로그램을 작성했습니다. 이것을 뒷받침하는 논리는 간단하며 우리는 이미 위에서 토론했다.

시간 복잡도는 O(N)이고 공간 복잡도는 O(1) 또는 상수입니다. 하지만, 사실 이 복잡성이 암시하는 것보다 더 복잡합니다.

> "숫자가 N < 94보다 작고 64비트 정수를 사용하는 경우 알고리즘은 선형 복잡성으로 작동합니다. 그러나 N > 94의 경우 2차 복잡도 알고리즘처럼 동작하기 시작합니다." ~ Michael Veksler

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_foR_1.png)

나는 파이썬의 `%time it` 모듈로 이것을 실행할 것이다. 이렇게 하면 실행 시간을 측정하기 위한 여러 가지 일반적인 트랩이 방지됩니다. 여기서 더 많은 용도를 볼 수 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_foR_R_1.png)

## 파이썬에서 재귀로 피보나치 시퀀스를 코드화하는 방법

여기서는 재귀로 시퀀스를 구현합니다. 재귀 함수는 기본 사례에 도달할 때까지 반복하여 호출하는 경향이 있습니다. 그래서, 재귀는 트리 구조를 만듭니다.

피보나치 시리즈가 5개라면, 이것은 재귀에 의해 만들어질 나무입니다.

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_foR_R2_1.png)

공간 복잡도는 O(N)이고 시간 복잡도는 O(2^N)입니다. 루트 노드에 2명의 자식과 4명의 손자가 있기 때문입니다. 보시는 바와 같이, 모든 노드에는 2명의 자녀가 있습니다.

깊이는 N입니다. 즉, 우리는 N번 해야 합니다. 또한 오른쪽 하위 트리가 왼쪽 하위 트리보다 작으므로 실제 런타임은 대략 O(1.6^N)입니다.

기본 사례: 피보나치(2) = 섬유(1) + 섬유(0) = 1 + 0 = 1

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_Recur_op_2.png)

재귀 피보나치 예제는 확실히 for 루프보다 빠릅니다.

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_Recur_R_2.png)

## Python에서 메모화를 사용하여 피보나치 시퀀스를 코드화하는 방법

메모화는 계산 부담을 줄임으로써 재귀 함수의 성능을 크게 향상시킬 수 있는 기법이다.

값비싼 함수 호출의 결과를 배열 또는 사전에 저장하고 동일한 입력이 호출될 때 캐시된 결과를 반환합니다.

위의 트리에서 참조할 수 있으며, 각 트리에서 특정 입력을 호출할 때마다 어떻게 재계산되는지 확인할 수 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_Memo_op_3.png)

시간 복잡도는 O(nlogn)입니다.

![image](https://www.freecodecamp.org/news/content/images/2020/11/serverCode_Memo_R_3.png)

## 재귀, 루프용, 메모 중 어느 것이 더 나은가?

자, 이런 기술들은 서로보다 더 낫지 않아야 합니다. 어떤 것을 사용해야 하는지 알면 됩니다. 물론 요구 사항에 따라 달라질 수 있습니다.

재귀가 재귀 호출 스택 프레임을 처리해야 하므로 반복이 재귀보다 빠릅니다. 그러나 재귀가 자동 호출을 최적화하는 언어로 작성되면 오버헤드가 제거되고 루프와 거의 동등한 수준이 됩니다.

마지막으로, 주의 공간이 희박할 때마다 메모화가 더 낫다. 즉, 더 작은 하위 문제가 모두 해결되어야 하는 것은 아니며, 그 중 일부만 해결하면 된다.

읽어주셔서 감사합니다! 이 기사가 마음에 드셨다면 제 다른 기사들도 읽어보실 수 있습니다. 당신은 이 기사를 공유함으로써 당신의 고마움을 표시할 수 있습니다. LinkedIn에서 저와 연결할 수도 있습니다.