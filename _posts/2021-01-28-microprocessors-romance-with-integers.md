---
layout: post
title: "음의 정수를 사용한 마이크로 프로세서의 로맨스 – CPU 산술 설계의 방법과 이유
 "
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2021/01/cover2.jpg
tags: SYSTEMS
---


컴퓨터에 대해 가장 먼저 배우는 것 중 하나는 컴퓨터가 0과 1 또는 비트 만 이해한다는 것입니다.
 

반면에 우리 인간은 십진법을 통해 숫자를 전달합니다.
 이 시스템은 플러스 및 마이너스 기호 (+ 및-)와 함께 0에서 9까지의 숫자를 사용하여 양수 또는 음수를 나타냅니다.
 

컴퓨터는 0과 1의 두 자리 만 사용할 수 있기 때문에 당시 엔지니어와 수학자는 음수를 표현하고이를 사용하여 산술을 수행하는 영리한 기술을 설계했습니다.
 이러한 기술의 아름다움을 살펴 보겠습니다.
 

## 첫째, 컴퓨터 작동 방식에 대한 배경 지식
 

소프트웨어, 이미지, 텍스트, 비디오, 숫자 및 그 사이의 모든 것은 컴퓨터의 가장 낮은 수준에서 0과 1입니다.
 

이미지, 텍스트, 비디오 및 숫자의 경우 이러한 항목이 0과 1에 도달하는 방법을 결정하는 인코딩 체계가 있습니다.
 예를 들어 텍스트의 경우 ASCII 및 유니 코드입니다.
 

우리가 코딩하는 소프트웨어 프로그램은 컴파일러와 어셈블러를 통해 0과 1에 도달합니다.
 기계 코드 (또는 기계 명령어)로 알려진 0과 1의 집합은 프로세서가 실행하기 전에 먼저 컴퓨터의 주 메모리 (RAM)에 저장됩니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/fetch-decode-exec.png)

프로세서는 주 메모리에서 명령을 가져와 실행주기를 시작하고 프로세서의 제어 장치는 이러한 명령을 연산 코드 (opcode)와 피연산자 두 부분으로 디코딩합니다.
 

opcode는 ADD (추가), JMP (점프), INC (증가) 등과 같이 수행해야하는 추가 작업을 결정합니다.
 피연산자는 해당 작업이 수행 될 값 (또는 메모리 위치)입니다.
 

디코딩 된 명령은 실행을 위해 ALU (Arithmetic and Logic Unit)로 전송됩니다.
 ALU에서 명령은 피연산자의 opcode를 기반으로 실행되며 결과는 메모리에 다시 저장됩니다.
 

예를 들어, 어셈블리 코드`ADD eax, 42`는 어셈블러에 의해 먼저 기계어 코드 (0s 및 1s)로 변환됩니다.
 그런 다음 페치-디코드-실행주기가 시작되기 전에 주 메모리에 저장됩니다.
 

메모리에서`ADD eax, 42`에 대한 기계어 코드 가져 오기가 완료되면 명령어가 디코딩됩니다.
 디코딩 된 출력은 opcode가`ADD`이고 피연산자가`eax` 및`42`라고 표시합니다.
 

`eax`는 레지스터 – 프로세서가 즉시 액세스 할 수있는 프로세서에 내장 된 메모리 위치입니다.
 `eax` 레지스터는 대부분의 프로세서에서 누산기라고합니다.
 

`ADD eax, 42` 어셈블리 코드는`eax` 레지스터 (누산기)의 현재 값에 42를 더하고 그 합계를`eax`에 저장하도록 설계되었습니다.
 `eax = eax + 42`입니다.
 

현재`eax`가 20이라고 가정하면`ADD eax, 42`를 실행 한 후`eax`의 값은 20 + 42 = 62가됩니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/Edvac-1.jpg)

EDVAC와 같은 초기 컴퓨터의 설계는 지루한 수학적 계산을 더 쉽고 빠르게 수행하려는 욕구에서 시작되었습니다.
 

컴퓨터 컴퓨팅을 만드는 모든 책임은 두 개의 숫자를 더하는 회로 인 가산기의 어깨에 있습니다.
 뺄셈, 곱셈 및 나눗셈과 같은 정교한 연산이 회로에서 가산기를 사용하기 때문입니다.
 

궁극적으로 컴퓨터는 논리 기능을 갖춘 빠른 산술 기계입니다.
 이진 산술 설계 (양수 및 특히 음수)의 과제와 아름다움을 이해하는 것은 컴퓨터 프로세서에서 가장 기본적인 개념 중 하나입니다.
 

먼저 십진수가 이진수로 표현되는 방법과 두 이진수 값을 더하는 방법을 살펴 보겠습니다.
 그런 다음 우리는 아름다움을 탐구하기 시작할 것입니다.
 

## 바이너리 시스템의 작동 원리
 

`872500`을 읽으라고하면 872.5K라고 말할 것입니다.
 우리 마음이 이것을 어떻게하는지 살펴 보자.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/decimal_sys_img-2.png)

우리는 1의 자리를 오른쪽에서 첫 번째 자리에 할당하고 10의 자리를 오른쪽에서 두 번째 자리에 할당하고 백분의 일부터 세 번째 자리까지 매번 10의 거듭 제곱 씩 증가합니다.
 

각 장소에서이 10의 거듭 제곱은 장소의 가중치입니다.
 백위의 무게는 100입니다.
 우리는 각 장소의 숫자에 장소의 무게를 곱하고 모두 합하여 완전한 숫자를 얻습니다.
 

위의 다이어그램에서 각 장소의 체중 증가가 `10 ^ 0 `에서 시작하여 `10 ^ 5`까지 10의 거듭 제곱임을 알 수 있습니다.
 이것이 십진수를 10 진수 시스템이라고 부르는 이유입니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/binary_sys_img-2.png)

바이너리에서 각 장소의 가중치는 2의 거듭 제곱만큼 증가합니다. 이는 장소의 가중치가 `2 ^ 0`에서 시작하여 `2 ^ something`에서 끝남을 의미합니다.
 그게 유일한 차이점입니다.
 

십진수로 `00110101`은 53으로 해석됩니다. 컴퓨터는 인간이 십진수를 해석하는 것과 같은 방식으로 이진수를 해석합니다. 즉, 각 장소의 숫자에 무게를 곱하고 합산하는 것입니다.
 

### 1과 0을 추가하는 방법
 

덧셈은 십진수에서와 거의 같은 방식으로 바이너리로 작동합니다.
 예를 통해 살펴 보겠습니다.
 2 개의 이진수를 추가합니다 :`1101` (13)과`1100` (12).
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/1-1.png)

십진법 에서처럼 우리는 1 자리 (`2 ^ 0`)에서 시작합니다.
 1과 0을 더하면 1이됩니다. 그래서 거기에 1을 넣습니다.
 나와 함께 있으면 전체 그림을 얻을 수 있습니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/2-1.png)

0 더하기 0은 0입니다. 계속 진행합니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/3-2.png)

1 더하기 1은 2이고 2 진수 2는 `10`으로 표시됩니다.
 우리는 1을 다음 자리로 옮기고 우리가있는 현재 자리의 결과로 0을 유지합니다. 이것은 소수점 덧셈으로 자리에서 9를 초과하는 것과 같지 않습니까?
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/4-1.png)

우리는 거기에 2 개의 1이 있고 이전 장소에서 이월 된 1 개의 1이 있으므로 총 3 개의 1이 있습니다.
 그들의 합은 3이 될 것이고 바이너리 3에서는`11`이 될 것이므로`11`을 씁니다.
 최종 결과는 10 진수 형식으로`11001` 또는 25가되며 실제로 13 + 12입니다.
 

위의 계산은 결과를 저장하는 데 사용할 수있는 5 비트가 있다고 가정합니다.
 4 비트 컴퓨터가이 추가 작업을 수행하면 결과를 저장하는 데 4 비트 만 사용할 수 있습니다.
 

이 다섯 번째 비트는 4 비트 컴퓨터에서 오버플로라고합니다.
 정수 산술에서 오버플로 비트는 무시되거나 삭제됩니다.
 따라서 우리가 4 비트 컴퓨터를 사용한다면 결과로`1001` (9)을 얻었을 것입니다.
 

## 이진 산술 디자인의 아름다움
 

앞으로 나아 가기 전에 이해해야 할 두 가지 중요한 용어는 최하위 비트와 최상위 비트입니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/lsb_msb-1.png)

가장 오른쪽에있는 비트는 가장 작은 자릿 가중치 (`2 ^ 0`)를 갖기 때문에 최하위 비트입니다.
 그리고 가장 왼쪽에있는 비트는 가장 높은 자리 가중치 (`2 ^ 7`)를 가지므로 가장 중요한 비트입니다.
 

세계에 양수 만 있었다면이 기사가 끝났을 것입니다 (이미 십진수를 이진수로 표현하는 방법과 이진수를 더하는 방법을 이미 배웠기 때문입니다).
 

고맙게도 우리는 음수도 있습니다.
 

CPU 산술 설계의 아름다움은 부정적입니다.
 

그렇다면 컴퓨터는 어떻게 음수를 나타내고, 음수에 대한 산술은 어떻게 작동합니까?
 이 문제에 대한 인코딩 접근 방식을 살펴 보겠습니다.
 

아래 섹션에서는 개념을 이해하기 위해 4 비트 컴퓨터로 작업 할 것입니다. 즉, 다섯 번째 비트는 오버플로로 처리됩니다.
 16 비트, 32 비트 또는 64 비트와 같은 모든 CPU 아키텍처에 동일한 원칙이 적용되어 산술을 수행합니다.
 

### 부호 크기 인코딩 방식
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/sign-bit01-1.png)

10 진수 형식의 `1101`은이 인코딩 체계에서 -5입니다.
 가장 왼쪽 또는 가장 중요한 비트는 부호 비트입니다.
 프로세서에게 숫자의 부호, 즉 숫자가 양수인지 음수인지를 알려줍니다.
 

부호 비트의 `0`은 양의 값을 나타내고 `1`은 음의 값을 나타냅니다.
 나머지 비트는 실제 크기를 알려줍니다.
 

`1101`에서 부호 비트는 `1`이므로 숫자는 음수입니다.
 `101`은 십진수로 5와 같습니다.
 따라서 `1101`은 십진수로 -5로 계산됩니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/4bit-1.png)

위의 다이어그램에서이 인코딩 방식을 사용하여 4 비트로 표현할 수있는 모든 정수를 볼 수 있습니다.
 이 시점까지 모든 것이 좋아 보입니다.
 

그러나 자세히 살펴보면이 인코딩 체계에서 매우 심각한 디자인 문제를 볼 수 있습니다.
 그 문제에 직면합시다.
 

양수와 음수를 더해 봅시다.
 예를 들어 +4와 -1을 추가합니다.
 답은`(+4) + (-1) = (+3)`, 즉`0011`이어야합니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/signbitproblem.png)

결과는`1101` (-5)입니다.
 실제 답은`0011` (+3)이어야합니다.
 프로세서에서이 접근 방식을 구현하려면이 문제를 처리하기 위해 로직을 추가해야하며 엔지니어는 로직의 추가 복잡성을 싫어합니다.
 

회로를 더 추가하면 전력 소비가 증가하고 성능이 저하됩니다.
 

이것은 최신 트랜지스터 기반 컴퓨터에서 사소한 문제처럼 들릴 수 있습니다.
 

그러나 하루에 수백 명의 사람들이 작동하는 킬로와트 단위의 전력을 소비하는 수천 개의 진공관에서 실행되는 EDVAC와 같은 초기 컴퓨터를 생각해보십시오.
 그리고 정부는 그들을 짓기 위해 수백만 달러를 썼습니다.
 

그 당시에는 추가 회로와 진공 튜브를 설치하는 것은 수천 달러의 비용과 심각한 유지 관리 문제를 의미했습니다.
 

그래서 엔지니어들은 더 스마트 한 인코딩 디자인을 생각해야했습니다.
 

이제이 문제를 해결하고 시스템을 더 간단하고 성능을 높이며 전력 소모를 줄일 수있는 아름다움을 밝혀 낼 때가되었습니다.
 

### 아름다운 인코딩 시스템이 들어가고 CPU가 빛납니다 ❤️
 

이 인코딩 체계에서 이전의 것과 마찬가지로 가장 왼쪽 비트는 부호 비트 역할을하지만 음수를 나타내는 데 일부 기술이 포함됩니다.
 

양수는 이전 인코딩 체계와 똑같은 방식으로 표현됩니다. 선행 `0`뒤에 크기에 대한 나머지 비트가 이어집니다.
 예를 들어,이 인코딩 체계에서도 6은 `0110`으로 표시됩니다.
 

음수를 나타 내기 위해 2 단계 수학 과정이 양수로 실행됩니다.
 -6을 나타내는 의미는 +6에 대해 2 단계 수학 과정을 수행하여 이진수로 -6에 도달합니다.
 

-6이 바이너리로 인코딩하는 방법을 살펴 보겠습니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/invert-1.png)

이전 부호 크기 접근 방식에서 +6의 음수를 계산하려면 부호 비트를 `0`에서 `1`로 변경했습니다.
 `0110`(+ 6)은 `1110`(-6)이됩니다.
 

이 새로운 인코딩 방식에서는 먼저 비트를 반전합니다.
 0을 1로, 1을 0으로 변경합니다.
 `0110`(+ 6)은 `1001`이됩니다.
 비트 반전을 "1의 보수"라고하므로 여기서는 `0110`의 1의 보수를 계산하여 `1001`이됩니다.
 그때...
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/-6-1.png)

1 단계에서 얻은 보수에`0001` (+1)을 더합니다 (`1001`).
 결과`1010`은 -6의 이진 표현이됩니다.
 이 인코딩 체계를 2의 보수라고합니다.
 따라서 양의 정수에 대한 2의 보수를 계산하면 음의 값을 얻을 수 있습니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/twocomplementshort-4.png)

반전 비트는 우리에게 1의 보수를 제공합니다.
 1의 보수에 1을 더하면 우리가 시작한 원래 비트의 2의 보수를 얻을 수 있습니다.
 간단 하죠?
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/2complement.png)

이제이 인코딩 체계가 왜 그렇게 아름다운지 살펴 보겠습니다.
 `0100`(+ 4)과 `1111`(-1)을 추가합니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/2complesolution.png)

우리는 2의 보수 인코딩 체계로 정확한 결과를 얻습니다.
 이제 부호에 대해 걱정하지 않고 정수를 더할 수 있습니다.
 

우리는 2의 보수 인코딩을 통해 음의 정수를 0과 1로 표현하는 방법을 배웠습니다.
 이제`ADD eax, -3`을 실행하고 eax 레지스터의 현재 값이 -1이라고 가정합니다.
 따라서`ADD eax, -3`을 실행 한 후 eax의 값은 -4 (2의 보수 인코딩에서`1100`)가됩니다.
 

운영 체제가 eax에서 `1100`을 검색하여 사용자에게 결과를 제공 할 때 운영 체제는 어떻게 `1100`을 십진수로 디코딩합니까?
 아니면 우리가 프로그래머로서`1100`을 접한다면`1100`이 무엇을 나타내는 지 어떻게 알 수 있을까요?
 

물론 우리는 `1100`에 도달했을 때를보기 위해 각 양의 정수의 2의 보수를 계속 계산할 수 없습니다.
 너무 느릴 것입니다.
 

프로그래머와 OS는 2의 보수라는 아름다운 속성을 사용하여 바이너리를 10 진수로 디코딩합니다.
 

양수에 대한 2의 보수를 계산할 때 음수를 얻습니다.
 음, 그 반대도 사실입니다. 즉, 음수의 2의 보수를 계산하면 양수를 얻을 수 있습니다.
 그 이유를 잠시 후에 살펴 보겠습니다.
 

먼저 OS 나 프로그래머가 `1100`을 십진수로 디코딩하는 방법을 이해합시다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/2complementexample-1.png)

eax 레지스터에서 `1100`을 검색 할 때 OS는 `1`을 정수가 음수임을 나타내는 부호 비트로 간주합니다.
 `1100`의 2의 보수는 `0100`(+ 4)으로 나오는 `1100`의 양수를 계산합니다.
 그런 다음 OS는 양수에 음수 부호를 추가하고 최종 답을 -4로 반환합니다.
 이 단락을 다시 읽으면 더 잘 이해할 수 있습니다.
 

그런 다음 CPU는 미소를 지으며 오늘의 아름다움에 작별 인사를합니다.)
 

CPU는 어머니를 만나기 위해 집으로갔습니다.
 이제 우리는 2의 보수 예술의 내부 작동에 대해 논의 할 충분한 시간을 가지고 있습니다.
 

## 2의 보완 인코딩은 왜 그리고 어떻게 작동합니까?
 

+42와 같이 숫자의 음수를 찾으라고하면 +42의 음수를 찾는 가장 간단한 방법은 무엇입니까?
 

가장 간단한 방법은 0에서 숫자를 빼는 것입니다.
 `0-(+42) = -42`.
 이것을 반복하면 양의 값`0-(-42) = + 42`로 돌아갑니다.
 이것은 2의 보수가 기초가되는 모든 수학입니다.
 

![image](https://www.freecodecamp.org/news/content/images/2021/01/zerominusnum-1.png)

우리는`10000` (가장 왼쪽 1이 오버플로이므로 십진수로 0)에서`0101` (+5)을 뺀 값을 수행합니다.
 2의 보수 인코딩에서 십진수로 -5 인`1011`을 얻습니다.
 뺄셈이 어떻게 수행되는지 무시하십시오.
 그것은 중요하지 않습니다.
 2의 보수 뒤에 숨겨진 직감을 이해하는 것이 중요합니다.
 

`10000`은`1111 + 0001`로 쓸 수 있습니다 (이 두 가지를 더하면`10000`이됩니다).
 그래서 실제로 우리는 다음과 같이하고 있습니다.
 

```undefined
        10000       -   0101
=>  (1111 + 0001)   -   0101

```

위의 방정식을 재정렬하면 다음과 같이 작성할 수 있습니다.
 

```undefined
    (1111 + 0001)  -  0101
=>  (1111 - 0101)  +  0001

Step 1: subtract 0101 from 1111

        1 1 1 1
       -0 1 0 1
       ---------
        1 0 1 0
        
       see, subtracting 0101 from 1111 is equivalent 
       to inverting the bits of 0101, as we got 1010 as a result. 

  
       
Step 2: add 0001 to the above result  

        1 0 1 0  ---> result of step 1
       +0 0 0 1
       ---------
        1 0 1 1      
       
       we get 1011 that is -5 in two's complement encoding.      

```

2의 보수 체계가 기본적으로 0에서 숫자를 뺀다는 것을 보셨나요?
 비트를 반전하고 1을 더하는 것은 0에서 숫자를 빼는 빠르고 영리한 방법입니다.
 

이것이 2의 보수를 계산할 때 음수의 양수와 양수의 음수를 얻는 이유입니다. 실제로 0 (`0-숫자`)에서 숫자를 빼기 때문입니다.
 

1900 년대의 컴퓨터는 덧셈 산술 논리 만 가지고있었습니다. 왜냐하면 2의 보수 인코딩 체계가 너무 아름다워서 뺄셈을 쉽게 수행 할 수 있기 때문입니다.
 

예를 들어 100에서 12를 빼기 위해 CPU는 -12를 생성하는 +12의 2의 보수를 계산 한 다음 -12에서 100을 더하여 필요한 출력을 제공합니다.
숫자의 음수를 찾기 위해 0에서 직접 빼거나 이진수로 그 반대로하지 않는 이유는 무엇입니까?
 

뺄셈은 느리고 복잡한 과정이기 때문에 (차용 덕분에) 우리가 그렇게한다면 우리 컴퓨터는 값 비싼 뺄셈 회로가 필요할 것입니다.
 음의 정수를 나타내려고 할 때마다 0에서 빼는 것을 상상해보십시오.
 그것은 우리와 우리 컴퓨터에게도 악몽이 될 것입니다!
 

2의 보완 인코딩은보다 성능이 뛰어난 솔루션이며 간단한 회로 설계로 이어지며 많은 비용을 절약합니다.
 뺄셈을 위해 값 비싼 회로가 필요하지 않고 + 및-정수의 산술을 처리 할 추가 논리가 없기 때문입니다.
 단순히 더하기 만하면 덧셈과 뺄셈을 모두 할 수 있습니다.
 

이 아름다운 인코딩 체계에 대해 컴퓨터 설계자에게 감사를 표합니다. 두 가지의 보완 ❤️.
 

## 마지막 단어
 

나는 내가 생산하는 어떤 학습 자료에 대해서도 비용을 청구하지 않겠다고 약속했습니다.
 내가 교육을 위해 무엇을하든 간단한 기사 든 강의 든 eBook이든 항상 100 % 무료이며 개방적입니다.
 

유용한 자료를 게시하고 내 트위터 계정에 의미있는 생각을 공유합니다.
 이 기사에서 새로운 것을 배웠다면 저를 팔로우하고 DM을 보낼 수 있습니다.
 내 하루를 만들거야 :)
 

모든 개발자, 모든 저자 및 모든 인간은 누군가로부터 배웁니다.
 저는 우리가 배운 사람과 자원이 인용되고 전파되어야한다고 믿습니다.
 이것은 좋은 사람들이 우리 모두를 위해 더 많은 일을하도록 장려합니다.
 그래서 여기에 좋은 것들이 있습니다.
 

mycodeschool의 Animesh는이 기사에서 작성한 개념을 포함하여 다른 누구보다 많은 프로그래밍 개념을 더 잘 가르쳐주었습니다.
 

나의 멘토이자 친구 인 André Jaenisch는 검토 노력과 끊임없는 지원 없이는이 기사를 쓰지 않았을 것입니다.
 

즐거운 학습 되세요!
 