---
layout: post
title: "새로운 리팩터링으로 계산시험을 보다 단순하고 표현력 있게 만드는 방법"
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2021/02/unit-testing-calculations.JPG
tags: undefined
---


가능한 한 기술적으로 테스트를 수행하는 것이 좋습니다. 테스트를 문서화하는 것이 좋습니다. 검정에 계산을 포함시키는 것은 이 작업의 큰 부분을 차지하며, 하드 코딩된 테스트 데이터 냄새를 피합니다.

예를 들어, 이렇게 보이는 검정은 검정 데이터가 모두 하드 코드화되어 있으므로 검정이 실패할 때 문제가 무엇인지 알 수 없습니다. 테스트는 테스트 대상 시스템(SUT)의 작동 방식에 대해 거의 알려주지 않으므로 설명서 역할을 하지 않습니다.

```python
assert sut.wake_erosion_rate(0.03) == 0.8

```

그러나 이 코드 냄새를 제거하고 계산에 포함시키면 오류가 발생할 때 문제가 무엇인지 분명해지며 이제 테스트가 문서 역할을 합니다.

2.5와 0.05를 나타내는 상수 이름으로 바꿀 수도 있습니다.

```python
ambient_turbuluence = 0.03

assert 
    sut.wake_erosion_rate(ambient_turbuluence) 
    == 2.5 * ambient_turbuluence + 0.05

```

이 글은 단위 시험 패턴과 관행에 대해 가장 널리 인정받는 어휘를 정의하는 우수한 X 단위 시험 패턴 책을 참조한다.

## 계산 예제

이 기사의 나머지 부분에서는 건설 마진 계산기 클래스 예제에 대해 논의하고, 테스트를 단순화하고 계산을 타당하게 포함시킬 수 있는 리팩터링에 대해 설명합니다.

계산은 30줄 내외로 지금 시간 되시면 한 번 훑어볼 만하다. 하지만 그렇지 않다면, 걱정하지 마세요, 이 게시물의 나머지 부분은 여전히 이치에 맞을 것입니다.

if 문장과 루프가 몇 개 있으며, 이 문들은 모두 2^9 또는 512로 이어집니다. 에크! 이것들을 모두 테스트하는 것은 분명히 실현 가능하지 않기 때문에, 그것을 더 쉽게 할 수 있는 방법을 찾을 필요가 있다.

이 예제 코드에는 약 30줄 길이의 초기 순진한 테스트가 있습니다. 계산은 포함되어 있지 않고, 그것들을 도입하면 시험이 훨씬 더 길고 복잡해지기 때문에 정당화하기가 어려울 것이다.

다음 각 절에서는 리팩터링에 대해 설명하고 리팩터링 예제 코드에 대한 링크를 포함합니다. 이는 X유닛 테스트 패턴의 기존 테스트 리팩터링을 기반으로 합니다.

리팩터링은 코드를 통과하는 경로의 수를 줄이고 테스트를 단순화합니다. 즉, 필요한 검정이 줄어들고, 검정이 계산을 포함할 수 있을 만큼 작고 간단해집니다.

## 루프에서 계산 추출

코드는 처음에 단계 목록에 대한 값을 계산하는데, 이는 단계 목록에 대한 모든 테스트가 이 복잡성에 대해 수행되어야 함을 의미한다.

단일 값이 아닌 리스트를 만들어야 하기 때문에 테스트 설정이 더 어렵습니다. 하나의 가치가 아닌 하나의 리스트에서 주장해야 하기 때문에 주장들이 더 어렵다. 마지막으로, 다중 검사(목록에 있는 0, 1 및 다중 항목에 대해)를 실시해야 합니다.

쉬운 해결책은 코드를 리팩터링하여 한 단계만 계산하게 하는 것이다. 이렇게 하면 반복 코드가 다른 위치로 대체되므로 테스트할 수 있습니다. 그러나 이 값은 Mock을 사용하여 테스트할 수 있으므로 반복만 테스트하면 됩니다(반복 및 계산과는 반대로). 이는 단순하고 잠재적으로 너무 간단하여 테스트할 필요가 없습니다.

이 리팩토링은 3개의 검정(목록에 있는 0, 1 및 다중 항목에 대해)을 요구하는 대신 이제 한 개만 있다는 것을 의미합니다. 이렇게 하면 코드를 통과하는 경로 수가 2^9에서 2^7 또는 128로 줄어듭니다. 이것은 이미 훨씬 더 낫지만 테스트하기에는 너무 많습니다!

- 리팩터링 계산
- 리팩터링 테스트

## 조롱할 수 있는 추상화 소개

인플레이션 계산의 자세한 내용은 예에 나와 있지 않지만, 상당히 복잡합니다.

이를 방지하기 위해 코드를 변경하여 `인플레이션 계산기`를 사용할 수 있습니다. 물가상승률 계산은 항상 동일한 `date_of_financial_close`, `inflation_rate`, `inflation_mode`를 사용하므로 건설업자가 이를 받아들일 수 있다. 이는 다시 주요 계산에서 더 이상 인플레이션과 인플레이션 모드를 요구하지 않는다는 것을 의미한다.

그런 다음 테스트에서 우리는 모의 인플레이션 계산기를 만들 수 있다. 이를테면 항상 `2` 값을 반환할 수 있으므로 전체 계산이 훨씬 간단해집니다.

또한 인플레이션 계산이 코드의 다른 부분에서 일어날 것이라는 것을 상상하기 쉬우므로 추상화는 널리 유용할 것이다.

이 단계는 물가상승률 계산에 4개의 조건부 분기가 있는 대신, 이제 한 개만 있다는 것을 의미한다. 이렇게 하면 코드를 통과하는 경로 수가 2^7에서 2^3 또는 8로 줄어듭니다. 인플레 계산기 시험도 필요하고, 여기에는 4개의 분기가 있어 4개의 분기가 필요하지만 아직 총 12개의 시험만 있다. 느슨하게 결합된 코드의 yay!

이제 쓸 수 있는 시험 횟수가 남아 있지만, 시험에 계산을 포함시키는 것은 여전히 매우 번거로울 것입니다. 다행히 아직 리팩터링이 남아있어요.

- 리팩터링 계산
- 리팩터링 테스트

## 격리된 상태 분기 테스트

코드는 특정 조건을 기반으로 분기됩니다. 이러한 조건 중 일부를 `거짓`으로 만든 다음 코드의 각 분기를 분리하여 테스트할 수 있습니다. 이렇게 하면 각 검정은 해당 분기에 대한 계산만 포함하면 됩니다.

예를 들어, 우리는 `in_selling_mode`를 `false`로, `step.start_of_step`을 `date_of_financial_close`로 다르게 설정할 수 있다. 이렇게 하면 코드가 수행하는 것과 동일한 계산을 수행할 수 있을 만큼 테스트가 간단해집니다.

이는 다시 이 테스트가 `turbine_cost_include_margin`이 `turbine_costs * fraction_of_spend * inflation`이어야 한다는 것을 분명하게 전달한다는 것을 의미한다. 이를 통해 독자는 계산기를 이해하고 테스트(Tests as Documentation)의 목표를 달성할 수 있습니다.

현재 시험은 아직 꽤 길다. 그러나, 우리는 계산의 작은 부분만을 시험하고 있기 때문에, 이 많은 정보들은 이제 무관하다(`any_double` 변수). 이제 테스트 데이터 작성기를 만들거나 도우미 기능을 사용하여 상황을 보다 간결하게 만들 수 있습니다. 우리는 다음 리팩터링에서 이것의 예를 볼 것이다.

- 계산 변경 안 함
- 리팩터링 테스트

## 격리된 값 테스트

"Test Conditional Branchs in Isolation"은 유용한 기술이지만, 값이 여러 분기에서 계산/업데이트되는 경우에도 여전히 몇 가지 복잡한 문제를 남길 수 있다.

이것의 좋은 예는 `balance_of_plant_cost_cost_include_margin`으로 처음에 설정되었다가 `if(in_selling_mode)` 분기에서 업데이트된다.

`balance_of_plant_cost_include_margin`을 분리하여 테스트하면 이 하나의 값/계산에만 집중할 수 있으므로 설정이 훨씬 덜 필요하다. 테스트 데이터 작성기 패턴은 관련 없는 정보를 숨기며, 테스트는 더욱 간결하고 표현력 있게 됩니다.

계산을 포함하면 테스트는 계속해서 의도를 명확히 전달하며 문서화 역할을 합니다. 흥미롭게도 테스트 계산 코드는 이미 `in_selling_mode`라는 것을 알고 있기 때문에 더 이상 SUT 계산 코드의 정확한 사본이 아니기 때문에 조건문이 필요하지 않다. 이는 시험이 코드보다 간단하다는 것을 의미하며, 이는 애매한 테스트 냄새를 피하도록 도와줍니다.

- 계산 변경 안 함
- 리팩터링 테스트

## 격리된 부분 값 테스트

때로는 개별 값의 계산이 매우 복잡하여 조건부 분기로 분할할 수 없습니다. 따라서 계산에 테스트에 포함하기가 어려울 수 있습니다. `건설_수익`은 다음과 같이 계산되는 타당한 예이다.

```python
step.turbine_cost_including_margin = 
 turbine_costs * inflation * fraction_of_spend;

step.balance_of_plant_cost_including_margin = 
 balance_of_plant_costs_at_financial_close * inflation * fraction_of_spend;

step.construction_profit = 
 -1 * 
 (step.turbine_cost_including_margin + step.balance_of_plant_cost_including_margin) *
 epc_margin

```

α, β_of_α, 엡c_α는 곱셈 효과가 있으므로 1로 설정하면 효과가 없고 나머지 논리에 대한 검정도 쉽게 쓸 수 있다.

`step.cost_include_cost_include_cost_include_step.balance_of_plant_cost_include_cost_include_clude_clude_clude_stependent`는 가법적인 효과가 있으므로 0으로 설정해도 효과가 없고 나머지 논리에 대한 검정도 쉽게 쓸 수 있다.

`건설_수익`의 일부만 분리하여 시험하면 계산의 이 부분에만 집중할 수 있어 이전과 같이 시험이 짧고 간단해지며 애매한 시험 냄새를 피할 수 있다.

- 계산 변경 안 함
- 리팩터링 테스트

## 칠판 패턴 소개

블랙보드 패턴은 더 복잡한 기술이며 종종 잘 이해되지 않는다. 그러나 본질적으로 그것은 복잡한 계산 내에서 의존성을 깨기 위해 "블랙보드"를 사용하는 것을 포함한다.

이 예에서 `건설_수익`은 입력에서 계산되는 `터빈_비용_포함_마진`과 `밸런스_of_plant_비용_포함_마진`에 따라 달라진다. 이것은 시험을 더 어렵게 만든다.

`건설_수익`을 시험하기 위해서는 기본적으로 turbine_cost_include_margin과 `balance_of_plant_cost_include_margin`도 시험해야 한다.

칠판 패턴을 도입할 때 한 계산기는 칠판에 turbine_cost_include_margin과 balance_of_plant_cost_include_margin을 쓰고, `건설_수익`을 계산할 때는 칠판에서 이 값을 읽는다.

이것은 두 가지 사이의 연결을 끊기 때문에, 우리는 테스트를 할 때 칠판에 turbine_cost_include_margin과 balance_of_plant_cost_include_margin에 대한 값을 추가할 수 있다.

- 리팩터링 계산
- 리팩터링 테스트

## 결론

계산을 테스트할 때는 계산을 테스트에 포함하는 것이 중요합니다. 이렇게 하면 하드 코딩된 테스트 데이터 냄새를 피할 수 있으며, 테스트에서 의도를 명확히 표현하고 테스트를 문서로 수행할 수 있습니다.

이 문서에 설명된 리팩터링을 통해 테스트를 간결하고 이해할 수 있도록 할 수 있습니다.