---
layout: post
title: "JVM 튜토리얼 - 초보자를 위한 Java 가상 머신 아키텍처 설명"
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2021/01/JVM.png
tags: undefined
---


Java를 사용하여 프로그램을 개발했는지 여부에 관계없이 JVM(Java Virtual Machine)에 대해 들어본 적이 있을 것입니다.

JVM은 자바 생태계의 핵심이며, 자바 기반 소프트웨어 프로그램이 "한 번 쓰기, 어디서나 실행"하는 방식을 따를 수 있게 한다. 한 시스템에서 Java 코드를 작성하고 JVM을 사용하여 다른 시스템에서 실행할 수 있습니다.

JVM은 처음에는 Java만 지원하도록 설계되었습니다. 그러나, 시간이 지남에 따라, 스칼라, 코틀린, 그루비 같은 많은 다른 언어들이 자바 플랫폼에 채택되었다. 이러한 모든 언어는 JVM 언어로 통칭된다.

이 기사에서는 JVM과 JVM의 작동 방식, 그리고 JVM이 만들어지는 다양한 구성 요소에 대해 자세히 알아보겠습니다.

JVM으로 전환하기 전에 VM(가상 시스템) 개념을 다시 살펴보겠습니다.

가상 시스템은 물리적 컴퓨터의 가상 표현입니다. 가상 머신을 게스트 머신이라고 부를 수 있으며, 가상 머신이 실행되는 물리적 컴퓨터가 호스트 머신입니다.

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-37.png)

단일 물리적 시스템은 여러 가상 시스템을 실행할 수 있으며, 각 가상 시스템은 자체 운영 체제 및 애플리케이션을 지원합니다. 이러한 가상 시스템은 서로 분리되어 있습니다.

C와 C++와 같은 프로그래밍 언어에서 코드는 플랫폼별 기계 코드로 먼저 컴파일된다. 이러한 언어들을 컴파일된 언어라고 부른다.

반면에 자바스크립트나 파이썬과 같은 언어에서는 컴퓨터는 명령어를 컴파일할 필요 없이 직접 실행한다. 이러한 언어들을 해석된 언어라고 부른다.

Java는 두 가지 기술의 조합을 사용합니다. 자바 코드는 클래스 파일을 생성하기 위해 바이트 코드로 먼저 컴파일된다. 그런 다음 이 클래스 파일은 기본 플랫폼에 대해 Java Virtual Machine에 의해 해석됩니다. 동일한 클래스 파일을 모든 플랫폼 및 운영 체제에서 실행되는 모든 JVM 버전에서 실행할 수 있습니다.

가상 시스템과 마찬가지로 JVM은 호스트 시스템에 분리된 공간을 생성합니다. 이 공간은 기계의 플랫폼이나 운영 체제에 관계없이 Java 프로그램을 실행하는 데 사용될 수 있습니다.

JVM은 세 가지 개별 구성 요소로 이루어집니다.

- 클래스 로더
- 런타임 메모리/데이터 영역
- 실행 엔진

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-39.png)

각각에 대해 좀 더 자세히 알아보도록 하겠습니다.

## 클래스 로더

.java 소스 파일을 컴파일하면 바이트 코드가 .class 파일로 변환됩니다. 프로그램에서 이 클래스를 사용하려고 하면 클래스 로더가 해당 클래스를 기본 메모리에 로드합니다.

메모리에 로드되는 첫 번째 클래스는 일반적으로 main() 메서드를 포함하는 클래스입니다.

클래스 로드 프로세스에는 로드, 링크 및 초기화라는 세 가지 단계가 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-40.png)

### 싣고 있는

로드에는 클래스 또는 인터페이스의 바이애코드(bytecode)를 특정 이름으로 사용하고, 그것으로부터 원래의 클래스 또는 인터페이스를 생성하는 것이 포함된다.

Java에는 세 가지 기본 제공 클래스 로더가 있습니다.

- 부트스트랩 클래스 로더 - 루트 클래스 로더입니다. Extension Class Loader의 슈퍼클래스로서, java.net, java.net, java.io 등 자바 표준 패키지를 로드한다. 이러한 패키지는 `rt.jar` 파일과 `$JAVA_`에 있는 기타 핵심 라이브러리 내에 있습니다.HOME/jre/lib` 디렉토리입니다.
- 확장 클래스 로더 - 부트스트랩 클래스 로더의 하위 클래스 및 응용 프로그램 클래스 로더의 슈퍼 클래스입니다. 이것은 `$JAVA_에 있는 표준 Java 라이브러리의 확장을 로드한다.HOME/jre/lib/ext` 디렉토리입니다.
- 응용 프로그램 클래스 로더 - 확장 클래스 로더의 최종 클래스 로더 및 하위 클래스입니다. 클래스 경로에 있는 파일을 로드합니다. 기본적으로 클래스 경로는 응용프로그램의 현재 디렉토리로 설정됩니다. 클래스 경로는 `-classpath` 또는 `-cp` 명령줄 옵션을 추가하여 수정할 수도 있습니다.

JVM은 클래스를 메모리에 로드하는 데 ClassLoader.loadClass() 메서드를 사용합니다. 정규화된 이름을 기준으로 클래스를 로드하려고 합니다.

부모 클래스 로더가 클래스를 찾을 수 없는 경우 작업을 자식 클래스 로더로 위임합니다. 마지막 자식 클래스 로더도 클래스를 로드할 수 없으면 `NoClassDefFoundError` 또는 `ClassNotFoundException`을 실행합니다.

### 링크

클래스는 메모리에 로드된 후 연결 프로세스를 거칩니다. 클래스 또는 인터페이스를 연결하는 것은 프로그램의 다양한 요소들과 의존성을 함께 결합하는 것을 포함한다.

링크에는 다음 단계가 포함됩니다.

확인: 이 단계에서는 제약 조건 또는 규칙 집합과 비교하여 `.class` 파일의 구조적 정확성을 확인합니다. 만약 어떤 이유로 인해 검증이 실패하면 우리는 `검증 예외`를 받는다.

예를 들어 Java 11을 사용하여 작성된 코드이지만 Java 8이 설치된 시스템에서 실행 중인 경우 확인 단계가 실패합니다.

준비: 이 단계에서 JVM은 클래스 또는 인터페이스의 정적 필드에 메모리를 할당하고 기본값으로 초기화합니다.

예를 들어, 클래스에 다음 변수를 선언했다고 가정합니다.

```undefined
private static final boolean enabled = true;
```

준비 단계에서 JVM은 변수 `enabled`에 메모리를 할당하고 값을 부울의 기본값인 `false`로 설정합니다.

해상도: 이 단계에서 심볼 참조는 런타임 상수 풀에 있는 직접 참조로 대체된다.

예를 들어 다른 클래스에 있는 다른 클래스 또는 상수 변수에 대한 참조가 있는 경우 이 단계에서 해당 참조가 해결되고 실제 참조로 대체됩니다.

### 초기화

초기화에는 클래스 또는 인터페이스(`clinit`로 알려진)의 초기화 방법이 포함됩니다. 여기에는 클래스의 생성자를 호출하고, 정적 블록을 실행하고, 모든 정적 변수에 값을 할당하는 작업이 포함될 수 있습니다. 이것이 클래스 로딩의 마지막 단계입니다.

예를 들어, 앞에서 다음 코드를 선언했을 때:

```undefined
private static final boolean enabled = true;
```

변수 enabled는 준비 단계에서 기본값인 false로 설정되었다. 초기화 단계에서 이 변수의 실제 값인 `true`가 할당됩니다.

참고: JVM은 다중 스레드입니다. 여러 스레드가 동시에 동일한 클래스를 초기화하려고 할 수 있습니다. 이로 인해 동시성 문제가 발생할 수 있습니다. 프로그램이 다중 스레드 환경에서 올바르게 작동하려면 스레드 안전을 처리해야 합니다.

## 런타임 데이터 영역

런타임 데이터 영역에는 다음과 같은 다섯 가지 구성 요소가 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-32.png)

각자 하나씩 살펴봅시다.

### 메서드 영역

런타임 상수 풀, 필드 및 메서드 데이터, 메서드 및 생성자 코드와 같은 모든 클래스 수준 데이터가 여기에 저장됩니다.

메서드 영역에서 사용할 수 있는 메모리가 프로그램 시작에 충분하지 않으면 JVM이 `OutOfMemoryError`를 실행합니다.

예를 들어 다음과 같은 클래스 정의가 있다고 가정합니다.

```undefined
public class Employee {
  
  private String name;
  private int age;
  
  public Employee(String name, int age) {
  
    this.name = name;
    this.age = age;
  }
}
```

이 코드 예제에서는 name, age 등의 필드 레벨 데이터와 생성자 세부 정보가 메서드 영역에 로드됩니다.

메서드 영역은 가상 시스템 시작 시 생성되며 JVM당 하나의 메서드 영역만 있습니다.

### 힙 영역

모든 개체와 해당 인스턴스 변수가 여기에 저장됩니다. 이 영역은 모든 클래스 인스턴스와 어레이에 대한 메모리가 할당되는 런타임 데이터 영역입니다.

예를 들어 다음 인스턴스를 선언한다고 가정합니다.

```undefined
Employee employee = new Employee();
```

이 코드 예제에서는 `직원` 인스턴스가 생성되어 힙 영역에 로드됩니다.

가상 시스템 시작 시 힙이 생성되고 JVM당 힙 영역이 하나만 있습니다.

참고: Method와 Hap 영역은 여러 스레드에 대해 동일한 메모리를 공유하므로 여기에 저장된 데이터는 안전하지 않습니다.

### 스택 영역

JVM에 새 스레드가 생성될 때마다 별도의 런타임 스택도 동시에 생성됩니다. 모든 로컬 변수, 메서드 호출 및 부분 결과는 스택 영역에 저장됩니다.

스레드에서 처리 중인 프로세스가 사용 가능한 스택 크기보다 더 큰 스택 크기를 필요로 하는 경우 JVM이 `Stack OverflowError`를 발생시킵니다.

모든 메서드 호출에 대해 스택 프레임이라고 하는 스택 메모리에서 하나의 항목이 만들어집니다. 메서드 호출이 완료되면 스택 프레임이 삭제됩니다.

스택 프레임은 세 개의 하위 부분으로 나뉩니다.

- 로컬 변수 – 각 프레임에는 로컬 변수로 알려진 변수 배열이 포함되어 있습니다. 모든 로컬 변수와 해당 값은 여기에 저장됩니다. 이 배열의 길이는 컴파일 시간에 결정됩니다.
- 피연산자 스택 – 각 프레임은 피연산자 스택으로 알려진 LIFO(Last-in-first-out) 스택을 포함합니다. 이것은 모든 중간 작업을 수행하는 런타임 작업 공간의 역할을 합니다. 이 스택의 최대 깊이는 컴파일 시간에 결정됩니다.
- 프레임 데이터 – 메소드에 해당하는 모든 기호가 여기에 저장됩니다. 예외 발생 시 캐치 블록 정보도 저장합니다.

예를 들어 다음과 같은 코드가 있다고 가정합니다.

```undefined
double calculateNormalisedScore(List<Answer> answers) {
  
  double score = getScore(answers);
  return normalizeScore(score);
}

double normalizeScore(double score) {
  
  return (score – minScore) / (maxScore – minScore);
}

```

이 코드 예제에서는 `답변`과 `점수`와 같은 변수가 로컬 변수 배열에 배치됩니다. 피연산자 스택에는 감산 및 나눗셈의 수학적 계산을 수행하는 데 필요한 변수와 연산자가 포함되어 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-36.png)

참고: 스택 영역은 공유되지 않으므로 본질적으로 스레드 안전합니다.

### 프로그램 카운터(PC) 레지스터

JVM은 동시에 여러 스레드를 지원합니다. 각 스레드에는 현재 실행 중인 JVM 명령의 주소를 저장할 자체 PC 레지스터가 있습니다. 명령이 실행되면 PC 레지스터는 다음 명령으로 업데이트됩니다.

### 네이티브 메서드 스택

JVM에는 기본 메서드를 지원하는 스택이 포함되어 있습니다. 이러한 방법은 C와 C++와 같은 자바 이외의 언어로 작성된다. 모든 새 스레드에 대해 별도의 네이티브 메서드 스택도 할당됩니다.

## 실행 엔진

바이트 코드가 기본 메모리에 로드되고 런타임 데이터 영역에서 세부 정보를 사용할 수 있게 되면 다음 단계는 프로그램을 실행하는 것이다. 실행 엔진은 각 클래스에 있는 코드를 실행하여 이 문제를 처리합니다.

그러나 프로그램을 실행하기 전에 바이트 코드를 기계어 명령으로 변환해야 한다. JVM은 실행 엔진에 인터프리터나 JIT 컴파일러를 사용할 수 있다.

![image](https://www.freecodecamp.org/news/content/images/2021/01/image-33.png)

### 통역사

인터프리터는 바이트 코드 명령을 줄줄이 읽고 실행합니다. 라인별 실행으로 인해 인터프리터가 상대적으로 느립니다.

해석자의 또 다른 단점은 어떤 방법이 여러 번 호출될 때 매번 새로운 해석이 필요하다는 것이다.

### JIT 컴파일러

JIT 컴파일러는 인터프리터의 단점을 극복한다. 실행 엔진은 먼저 인터프리터를 사용하여 바이트 코드를 실행하지만, 반복되는 코드를 발견하면 JIT 컴파일러를 사용한다.

그런 다음 JIT 컴파일러는 전체 바이트 코드를 컴파일하고 이를 네이티브 머신 코드로 변경한다. 이 네이티브 머신 코드는 반복적인 메소드 호출에 직접 사용되어 시스템의 성능을 향상시킨다.

JIT 컴파일러에는 다음과 같은 구성 요소가 있습니다.

- 중간 코드 생성기 - 중간 코드를 생성합니다.
- 코드 최적화 도구 - 성능 향상을 위해 중간 코드를 최적화합니다.
- 대상 코드 생성기 - 중간 코드를 네이티브 시스템 코드로 변환
- 프로파일러 - 핫스팟(반복적으로 실행되는 코드)을 찾습니다.

인터프리터와 JIT 컴파일러의 차이점을 더 잘 이해하려면 다음 코드가 있다고 가정합니다.

```undefined
int sum = 10;
for(int i = 0 ; i <= 10; i++) {
   sum += i;
}
System.out.println(sum);
```

인터프리터가 루프에서 반복할 때마다 메모리에서 sum 값을 가져와 i 값을 추가한 다음 메모리에 다시 씁니다. 루프에 들어갈 때마다 메모리에 액세스하기 때문에 비용이 많이 드는 작업입니다.

그러나 JIT 컴파일러는 이 코드가 핫스팟을 가지고 있다는 것을 인식하고 최적화 작업을 수행한다. 스레드용 PC 레지스터에 sum의 로컬 사본을 저장하고 루프에 i 값을 계속 추가할 예정이다. 루프가 완료되면 sum 값을 메모리에 다시 씁니다.

참고: JIT 컴파일러는 인터프리터가 코드 라인을 라인별로 해석하는 것보다 코드를 컴파일하는 데 더 많은 시간이 걸린다. 프로그램을 한 번만 실행하려면 인터프리터를 사용하는 것이 좋습니다.

### 가비지 수집기

GC(Garbage Collector)는 참조되지 않은 개체를 수집하여 힙 영역에서 제거합니다. 런타임 미사용 메모리를 파괴하여 자동으로 회수하는 과정이다.

가비지 컬렉션은 참조되지 않은 개체를 힙 메모리에서 제거하고 새 개체를 위한 여유 공간을 만들기 때문에 Java 메모리를 효율적으로 만듭니다. 여기에는 두 가지 단계가 포함됩니다.

- 표시 - 이 단계에서 GC는 메모리에서 사용되지 않는 개체를 식별합니다.
- 스위프 - 이 단계에서 GC는 이전 단계에서 식별된 객체를 제거합니다.

가비지 컬렉션은 JVM에 의해 정기적으로 자동 수행되므로 별도로 처리할 필요가 없습니다. 또한 "System.gc()를 호출하여 트리거할 수 있지만 실행이 보장되지는 않습니다.

JVM에는 세 가지 유형의 가비지 수집기가 포함되어 있습니다.

- 직렬 GC - GC의 가장 간단한 구현으로, 싱글 스레드 환경에서 실행되는 소규모 애플리케이션을 위해 설계되었습니다. 가비지 수집을 위해 단일 스레드를 사용합니다. 실행되면 전체 응용프로그램이 일시 중지되는 "세계 중지" 이벤트로 이어집니다. 직렬 가비지 수집기를 사용할 JVM 인수는 `-XX:+SerialGC 사용`
- 병렬 GC - 이것은 JVM에서 GC의 기본 구현이며, 처리량 수집기라고도 합니다. 가비지 수집에는 여러 스레드를 사용하지만 실행 시 응용 프로그램을 일시 중지합니다. 병렬 가비지 수집기를 사용할 JVM 인수는 `-XX:+ParallelGC`를 사용합니다.
- 가비지 퍼스트(G1) GC - G1GC는 사용 가능한 큰 힙 크기(4GB 이상)를 가진 다중 스레드 애플리케이션을 위해 설계되었다. 힙을 동일한 크기의 영역으로 분할하고 여러 스레드를 사용하여 검색합니다. G1GC는 가비지가 가장 많은 지역을 식별하고 먼저 해당 지역에서 가비지 수집을 수행합니다. G1 가비지 수집기를 사용하는 JVM 인수는 `-XX:+G1GC 사용`

참고: CMS(Concurrent Mark Sweep) GC라는 다른 유형의 가비지 수집기가 있습니다. 그러나 자바 9 이후로 더 이상 사용되지 않으며 자바 14에서 G1GC를 위해 완전히 제거되었다.

## Java 네이티브 인터페이스(JNI)

때로는 네이티브(Non-Java) 코드(예: C/C++)를 사용해야 합니다. 이는 하드웨어와 상호 작용해야 하거나 Java의 메모리 관리 및 성능 제약 조건을 극복해야 하는 경우일 수 있습니다. Java는 JNI(Java Native Interface)를 통해 네이티브 코드의 실행을 지원합니다.

JNI는 C, C++ 등과 같은 다른 프로그래밍 언어에 대한 지원 패키지를 허용하는 브리지 역할을 한다. 이는 특히 C에서만 쓸 수 있는 일부 플랫폼별 기능처럼 Java에서 완전히 지원하지 않는 코드를 작성해야 하는 경우에 유용합니다.

네이티브 키워드를 사용하여 메서드 구현이 네이티브 라이브러리에서 제공됨을 나타낼 수 있습니다. 또한 공유 네이티브 라이브러리를 메모리에 로드하고 Java에서 해당 기능을 사용하려면 `System.loadLibrary()`를 호출해야 합니다.

## 네이티브 메서드 라이브러리

네이티브 메소드 라이브러리(Native Method Libraries)는 C, C++, 어셈블리 등의 다른 프로그래밍 언어로 작성된 라이브러리이다. 이러한 라이브러리는 일반적으로 .dll 또는 .so 파일 형식으로 표시됩니다. 이러한 네이티브 라이브러리는 JNI를 통해 로드할 수 있습니다.

- ClassNotFoundException - 클래스 로더가 `Class.forName()의 `ClassLoader.loadClass()` 또는 `ClassLoader.findSystemClass()`를 사용하여 클래스를 로드하려고 하지만 지정한 이름의 클래스에 대한 정의를 찾을 수 없는 경우에 발생합니다.
- NoClassDefFoundError - 컴파일러가 클래스를 성공적으로 컴파일했지만 Class Loader가 런타임에 클래스 파일을 찾을 수 없을 때 발생합니다.
- OutOfMemoryError - JVM이 메모리가 부족하여 개체를 할당할 수 없으며 가비지 수집기에서 더 이상 메모리를 사용할 수 없을 때 발생합니다.
- 스택 오버플로 오류 - 스레드를 처리하는 동안 새 스택 프레임을 생성하는 동안 JVM의 공간이 부족할 경우 발생합니다.

이 기사에서는 Java Virtual Machine의 아키텍처와 해당 아키텍처의 다양한 구성 요소에 대해 논의했습니다. 종종 우리는 JVM의 내부 역학에 대해 깊이 파고들지 않거나 코드가 작동하는 동안 어떻게 작동하는지 신경 쓰지 않는다.

단지 무언가가 잘못되었을 때, 우리는 JVM을 수정하거나 메모리 누수를 고칠 필요가 있을 때, 그것의 내부역학을 이해하려고 노력합니다.

이것은 백엔드 역할의 주니어 레벨과 시니어 레벨 모두에서 매우 인기 있는 인터뷰 질문이기도 합니다. JVM을 깊이 이해하면 코드를 더 잘 작성하고 스택 및 메모리 오류와 관련된 함정을 방지할 수 있습니다.

지금까지 나와 함께 있어줘서 고마워. 그 기사가 마음에 들었길 바라. 기술과 생활에 대해 정기적으로 논의하는 LinkedIn에서 저와 연결할 수 있습니다. 그리고 제 다른 기사들과 유튜브 채널도 보세요. 즐거운 독서. 🙂