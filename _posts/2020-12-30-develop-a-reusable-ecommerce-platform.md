---
layout: post
title: "재사용 가능한 전자상거래 플랫폼을 개발하는 방법"
author: 'Code Tower'
thumbnail: https://www.freecodecamp.org/news/content/images/size/w600/2020/12/plants.jpg
tags: undefined
---


이 내용은 단일 eCommerce 플랫폼이 아니라 다른 소유주를 위해 재사용 가능한 플랫폼을 개발하는 저희 팀의 노력에 대한 이야기입니다. 우리는 동일한 코드베이스, 모양, 느낌을 유지했고 그것을 매우 사용자 정의 가능하게 만들었습니다.

그 과정에서 배운 내용으로 마무리하겠습니다. 우리의 테이크아웃은 다른 소프트웨어 개발자들(그리고 미래의 프로젝트에서도 우리 자신에게)에게 유용한 학습 자원이 될 것이라고 생각한다.

이해하기가 쉽도록 최대한 관련 부분에 집중하도록 노력하겠습니다. 이런 말을 했으니 이 기사를 검토하려면 약간의 배경이 필요하다.

## 목차.

- 프로젝트 컨텍스트
- 최초의 MVP
- 그래프 구현QL
- 아키텍처 및 기술 스택
- 두 번째 MVP
- 결론 및 학습된 교훈
- 마지막 생각

## 프로젝트 컨텍스트

우리가 플랫폼을 개발하던 고객은 3개의 주요 서브 기업으로 구성된 eLearning 회사였습니다.

지난 몇 년 동안, 하위 회사들은 대부분 독립적으로 운영되어 왔다. 하지만 이제 그들은 표준화된 작업 방식을 만들어내려고 노력했습니다. 그래서 그들은 최상의 방법으로 함께 성장할 수 있었습니다.

그 프로젝트는 야심찬 것이었다. 모든 하위 회사에 적합한 전자상거래 플랫폼을 만드는 것은 설계하거나 구현하기가 쉽지 않았습니다. 미해결 문제가 많아 추정이 매우 어려웠다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/doubts-2.gif)

## 최초의 MVP

이 어려운 과제를 해결하기 위해, 우리는 3개의 하위 회사 중 하나인 H라는 하위 회사로부터 시작하였습니다. 사실, 그것은 주요 하위 회사들 중 하나가 아니라, 하위 회사로부터의 서브 회사였습니다.

좀 더 잘 설명하자면, 우리가 3개의 주요 하위 회사 이름을 L, N, P로 지으면 H는 N의 하위 회사였습니다.

서브 서브 서브 회사가 된다는 것이 플랫폼을 더 쉽게 개발할 수 있다는 것을 의미하지는 않았다. 사실 MVP를 위해 제안된 모든 특징들을 볼 때, 그것은 정반대였다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/main_company_structure-1.jpg)

사용자가 제품을 구입할 수 있는 것이 주된 목표였지만(상당히 분명한 것처럼 보이지만) 다른 서비스와의 의존도가 너무 많아서 겉으로 보기에 단순한 MVP를 달성할 수 없었다.

제품 및 주문 정보의 일부는 다른 팀의 도메인인 Integration team(team In)에서 가져온 것입니다. 그들은 우리가 주문 상태와 함께 제품의 정보를 저장하는 전자상거래 시스템인 Swell과 Klopek와 통신했습니다.

할인 혜택은 인 팀에서도 제공했는데, 이 팀에서는 사용자 정보와 권한에 따라 최종 제품 가격을 계산한 뒤 전시해야 했습니다.

이미지 또는 설명과 같은 제품 콘텐츠를 클라이언트가 쉽게 관리할 수 있는 컨텐츠 플랫폼인 Contentful을 통해 액세스하고 사용자 정의할 수 있도록 했습니다.

우리는 결제 서비스인 Stripe로 결제를 관리했고, In팀과 소통하여 Swell에 대한 주문 상태를 업데이트했습니다.

사용자가 인증할 수 있는 서비스는 소유자와 무관해야 하며 모든 하위 회사에서 재사용할 수 있어야 합니다. 다른 팀에서 제공해야 했지만, 결국 우리가 직접 개발했습니다.

그리고 금상첨화를 위해, 우리는 또한 웹과 모바일 앱에서 사용자 이벤트를 수집하는 인기 서비스인 Segment(세그먼트)로 사용자 추적을 구현해야 했습니다.

여기 제가 설명했던 간단한 다이어그램이 있는데, 이 다이어그램은 이해하기 쉬울 수 있습니다. 단순성을 유지하기 위해 백엔드 및 프런트엔드에서만 마이크로서비스 아키텍처를 그룹화했습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/mvp_architecture_overview-1.jpg)

## 그래프를 선택한 이유QL

프로젝트 목표를 달성하기 위해 백엔드로부터 제품 핵심 정보의 고유한 진실성 소스를 프런트 엔드에게 제공해야 했습니다.

따라서 우리가 목표로 삼은 것은 한 상점의 프런트 엔드와 다른 상점에 대한 유일한 목적은 Contentful의 디자인과 내용일 것입니다.

이러한 설계와 React에 대한 구현과 관련하여, 우리는 공유 구성 요소 라이브러리를 사용할 계획이었다.

따라서, GraphQL은 여기서 무엇을 하고 있으며, 왜 우리가 그것을 하기로 결정했을까요?

그래프QL의 작동 방식을 모르는 경우 기본적으로 제품에 적용할 수 있는 모든 속성 및 쿼리로 스키마를 정의할 수 있습니다. 그런 다음 프런트 엔드로 서비스를 제공하여 백엔드가 REST 서비스와 같이 각 요청에 대한 끝점을 생성할 필요 없이 요청할 항목을 결정할 수 있습니다.

그것에 대해 더 알고 싶다면, 내가 그것을 설명하기 위해 쓴 이 튜토리얼을 보세요. Node.js에서 사용하는 방법을 알려줍니다. 또한, 그들의 문서는 확인해 볼 가치가 있다.

이는 각 상점들이 진실의 근원인 스키마를 보는 것만으로도 제품에 필요한 데이터를 요청한다는 것을 의미했다.

이러한 사실 덕분에 우리는 각 상점마다 백엔드에 서로 다른 데이터 소스를 구현할 필요가 없게 되었습니다. 이를 통해 프런트 엔드에는 각 인터페이스에 표시되는 데 필요한 제품 데이터를 요청할 수 있는 힘과 책임(첫 번째 🕷는 두 번째 🕷와 관련되어 있음)이 부여되었습니다.

> 큰 힘이 있으면 큰 책임이 따른다.
— 스탠 리

확실히 말씀드리자면, REST를 선택했다면 각 상점마다 다른 엔드포인트를 만들어야 했을 것입니다. 아니면 프런트 엔드가 각 상점에 있는 모든 제품 데이터를 검색하도록 한 다음 표시할 속성을 결정해야 했을 것입니다. 즉, 불필요한 데이터를 프론트 엔드에 저장해야 하므로 노이즈만 가중됩니다.

더 심각한 것은, 모든 상점의 백엔드 서비스를 각 프런트 엔드 상점에 배포했을 것이라는 점입니다. 이것은 불필요한 자원을 사용하고 비용을 상당히 증가시켰을 것이다.

이것이 우리가 이 초기 접근 방식을 택한 이유이다. 제 생각에 최악의 부분은 우리가 만들었던 모든 엉망진창들을 유지하느라 시간을 낭비하는 것이었을 것입니다.

또한 주문형 단일 요청을 함으로써 페이로드가 가벼워졌고, 따라서 네트워크를 통한 성능이 향상되었다.

어쨌든, 모든 문제와 마찬가지로, 이 프로젝트와 아키텍처를 개발하는 과정에서 우리가 취할 수 있었던 다른 접근 방식들이 있었습니다. 하지만 그 순간, 우리에게 이것은 가장 좋은 것으로 보였다.

## 아키텍처 및 기술 스택

마이크로서비스 아키텍처는 주로 Azure K8s 클러스터에서 호스팅되는 Node.js 서비스로 구성되었다. 그들의 요구와 함께 작업한 데이터에 따라, 그들은 MongoDB, Postgre를 가지고 있거나 가지고 있지 않았다.SQL 또는 Redis 데이터베이스가 연결되어 있습니다.

이들 간의 비동기식 통신은 주로 Azure Service Bus 주제와 구독을 통해 게시/구독 메시징 통신 모델을 통해 처리되었다.

일반적인 메시징 대기열의 주요 차이점은 수신기를 둘 이상 가질 수 있기 때문에 둘 이상의 서비스에서 메시지를 수신할 수 있는 대기열이 여러 개 없다는 것입니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/azure_service_bus_messaging_queues-1.png)

![image](https://www.freecodecamp.org/news/content/images/2020/12/azure_service_bus_messaging_topics-1.png)

프론트 엔드 부분에서는 React와 함께 사이트를 개발했습니다. 때로는 복잡성과 각 요구 사항에 따라 Create React App을 사용하여 Next와 다른 애플리케이션을 처음부터 사용한 적도 있습니다.

우리는 대부분의 상태를 관리하기 위해 이전 프로젝트에서 사용되던 Redux에서 공식 Context API로 이동했습니다.

첫 번째 MVP 아키텍처의 주요 서비스와 기능은 다음과 같습니다.

- 샵-웹 앱: 클라이언트 상점 응용 프로그램입니다.
- gateway-api-service: 클라이언트로부터 요청을 수신하여 해당 서비스로 리디렉션하는 프록시 서비스입니다.
- cms-api-service: 콘텐츠에서 콘텐츠를 검색하고 서비스하는 서비스
- 카탈로그-api-service: Team In 메시지를 구독하고 나중에 GraphQL을 통해 이를 서비스하기 위해 제품 핵심 데이터를 지속하는 서비스입니다.
- 주문-api 서비스 모든 지급 비즈니스 로직을 처리하는 서비스
- auth-api-service: 사용자 인증을 구현하여 제품을 구입할 수 있는 임시 서비스입니다.
- auth-web-app: 인증 서비스의 클라이언트입니다.
- 통합-전자 상거래-api-서비스: 결제를 처리하는 통합 도메인의 서비스입니다. 비록 이 서비스가 우리 영역에는 없었지만, 우리는 배달 속도를 높이고 추가 작업으로부터 그들을 해방시키기 위해 함께 개발했습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/first_mvp_arquitecture-1.jpg)

Azure에 필요한 리소스를 배포하고 업데이트하기 위해 인프라를 코드로 정의하고 K8s 클러스터의 수명 주기를 관리할 수 있는 Terraform을 사용했습니다. 또한 Azure DevOps와 함께 CI로 작업했습니다.

서비스에서는 시스템에서 구성 요소와 해당 종속성을 생성할 수 있는 최소 종속성 주입을 위한 Node.js 프레임워크인 Systematic을 사용했습니다. 각 구성 요소는 라우팅, 컨트롤러, 서비스, 데이터베이스 등과 같은 도메인에서 다른 구성 요소와 무관하게 별도의 개체를 처리합니다.

아폴로는 그래프QL을 구현하기 위한 우리의 선택이었다. 프런트 엔드와 백엔드를 모두 쉽게 연결할 수 있는 데이터 그래프 계층을 제공했습니다.

자세한 내용은 해당 문서 또는 이 튜토리얼을 참조하십시오.

마지막으로, 우리는 GitHub에서 코드를 호스팅하여 Pull Requests와 같은 기능을 사용하여 코드를 구현하기 전에 코드를 제대로 검토했다.

## 두 번째 MVP

MVP(Minimum Available Product)는 프로젝트에서 생성하고 제공하는 최초의 시제품입니다. 즉, 일반적으로 하나만 존재하며, 생성하면 새 기능을 구현하기 시작합니다.

그렇다면, 왜 우리는 같은 프로젝트를 위해 두 번째 MVP에 집중했을까요? 글쎄요, 우리가 첫 번째 버전의 "안정적"에 도달했을 때, 고객은 우리가 주요 서브 컴퍼니 매장부터 시작해야 한다는 것을 깨달았습니다. 그들은 새로운 회사들의 개발에 집중하기 위해 서브 서브 서브 회사 H 스토어 개발을 중단하기로 결정했다.

이는 주로 일부 서비스가 향후 몇 개월 동안 하위 기업에 대한 지원을 종료했기 때문인데, 이는 해당 업체의 매장이 먼저 개발되어야 한다는 것을 의미했다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/how_we_felt_with_second_mvp-1.jpg)

첫 MVP를 제대로 평가하려고 노력했지만, 도중에 계획되지 않은 이슈가 나타나면서 마감일을 넘겼다. 따라서, 새로운 마감일이 훨씬 더 빠를 것이라는 말을 들었을 때, 우리는 제 시간에 도달하기 위해 다른 접근법을 취하기로 결정했습니다.

우리는 동시에 두 개 이상의 매장을 개발하기로 결정했는데, 이는 양날의 칼날 같은 접근이었다.

한편으로, 우리는 플랫폼의 재사용 가능성의 측면이 얼마나 잘 작동하면서 리팩토링되는지 이동 중에 확인할 수 있었습니다. 우리는 또한 결국 둘 이상의 상점을 갖게 될 것이다.

반면에, 우리는 여러 상점의 환경과 자원을 설정하고 유지해야 할 것이다. 게다가 우리는 우리의 속도를 늦출 수 있는 그들의 디자인을 구현해야 할 것입니다. 이것은 우리가 제시간에 마감에 도달하지 못할 수도 있다는 것을 의미합니다.

우리는 이 MVP를 다시 시작하고 코드베이스를 개선할 수 있는 기회로 보았다. 그래서 우리는 반응 애플리케이션에 TypeScript와 Styled-Components를 추가했습니다.

저는 우리가 이런 선택을 했을 때 매우 행복했다는 것을 인정해야 합니다. 왜냐하면 저는 제 프로젝트를 위해 그 스택을 작업해 왔기 때문입니다. 그래서 이제 저는 더 많은 것을 배울 수 있었고 더 잘 할 수 있었습니다.

다행히도, 이전 MVP의 코드 대부분을 React 애플리케이션 및 백엔드 서비스에 다시 사용할 수 있었습니다. 하지만 모든 것이 장미꽃 침대만은 아니었다.

우리 모두가 이 새로운 스택을 사용하는 데 익숙하지 않아서 처음에는 속도가 느려졌습니다. 또한 동일한 스택으로 모든 플랫폼을 위한 React 구성 요소 라이브러리를 개발하기 시작했는데, 첫 번째 MVP를 위해 계획되었지만 빛을 보지 못했다.

그때쯤 사용자 인증 서비스를 담당하는 팀이 작업을 시작했기 때문에 개발을 중단하고 현장에 구현만 했습니다.

또한, Azure Cognitive Search를 통해 제품 검색 서비스(Search-api-Service) 개발을 시작했습니다.

위에 언급된 모든 변화 후에 건축은 이렇게 진화했습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/second_mvp_arquitecture.jpg)

## 결론 및 학습된 교훈

이 글을 쓰는데 아직 플랫폼이 완성되지 않았습니다. 하지만 우리가 있는 곳에 도달하는 것은 큰 도전이었습니다.

우리는 위에서 설명한 스택과 아키텍처뿐만 아니라 우리가 팀으로 일하는 방식에 대해서도 다른 사람들에게 유용할 수 있는 몇 가지 귀중한 교훈을 배웠습니다.

### 스택 혁신

신기술로 일하는 것은 오래되고 잘 알려진 기술을 고수하는 것보다 위험하고 덜 편안할 수 있다. 그러나 혁신과 적응성은 소프트웨어 개발에서 뒤처지지 않도록 하는 올바른 방법입니다.

스택을 업그레이드하거나 새로운 스택을 채택할 때 가장 중요한 점 중 하나는 다음 표준을 따르는 적절한 방법을 확인하는 것 외에 팀이 스택을 사용하는 데 편안함을 느끼는지 확인하는 것입니다. 처음뿐만 아니라, 전환 과정을 더 쉽게 하기 위한 과정에서도 마찬가지입니다.

### 과소평가하지 말고, 약속하지 말고, 더 많은 것을 제공하라.

우리는 첫 번째 MVP를 기쁘게 평가했고 많은 기능을 제공하기로 동의했어요. 우리는 도중에 나타난 모든 문제들 때문에 더 많은 시간이 필요하게 되었고 때로는 "아니오"라고 말하는 법을 배워야 했다.

두 번째 MVP에서는 그렇게 먼 장래를 예측하지 못했으며, 예상한 시간 내에 제공할 수 있을지 확신할 수 없는 기능에 전념하지 않았습니다.

이 덕분에, 우리는 그들이 그 진행에 실망하지 않았기 때문에 스트레스를 덜 받고, 기분이 더 좋아지고, 코드를 더 잘 전달하며, 프로젝트에 대한 고객의 감정을 개선할 수 있었습니다.

### 팀 내 팀워크.

우리는 기술을 사용하는 것뿐만 아니라 가장 중요한 것은 팀원들에게 편안함을 느끼는 것이 발전하고 발전하는 가장 좋은 방법이라는 것을 깨달았습니다. 우리의 관계와 팀워크를 향상시킨 몇 가지 조치는 다음과 같았다.

지금 우리가 하고 있는 일이 무엇이든지 간에, 우리는 모두 같은 목소리를 가지고 있었고, 선택을 할 때 우리의 의견은 똑같이 반영되었다. 이는 새로운 스택의 채택과 우리가 따를 관행에 대해 논의할 때 핵심이었습니다.

피드백은 코드 자체뿐만 아니라 코드 작성 방식도 개선할 수 있는 가장 좋은 방법 중 하나입니다. 그렇기 때문에 GitHub Pull Requests와 협력하여 대부분의 기능을 구현하기로 결정했습니다.

이들과 함께 작업함으로써 코드베이스를 개선할 뿐만 아니라 다른 영역에서 기능이 구현되는 방식을 알게 되었고, 회의 일정을 모두 회피하고 프로젝트 전체 범위를 추적할 수 있었습니다.

우리는 최소의 검토자 수와 같은 기능으로 이 시스템을 조금씩 개선하여 이들을 병합하거나 느슨하게 하여 가입시켰다.

내 생각에는, 이것은 필수품이다. 팀은 막히면 도움을 청하는 두려움을 버려야 한다. 동시에, 그들은 다른 사람들이 그것을 요구할 때 기꺼이 도와주어야 한다.

나는 우리가 이 균형에 도달할 수 있었고 여러 가지 면에서 우리의 일이 향상되었다고 말할 수 있어서 기쁘다. 다음 포인트인 페어링은 도움을 청하고 서로를 더 잘 알게 되는 두려움을 없애는 데 핵심이었습니다.

소프트웨어 개발의 이 시점에서, 쌍 프로그래밍을 하는 것의 장점은 꽤 잘 알려져 있다. 우리는 더 빠르고 더 나은 방식으로 기능을 제공하기 위해서만이 아니라 서로의 코딩 방식에서 배우기 위해서도 짝을 이뤘습니다.

매주, 우리는 그것들을 실행할 쌍작업과 팀원들을 결정했다. 하지만 누군가 필요하거나 짝을 짓고 싶다면, 우리는 단지 그것을 요청했고 팀 동료가 도움을 준 직후에 요청했습니다.

스프린트 회고전은 잘 된 일, 잘못 된 일, 변화를 제안하고 개선을 기대할 수 있는 완벽한 순간이었다. 따라서 우리는 의견을 나눌수록 더 많은 문제에 접근하고 해결할 수 있습니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/teamwork_makes_the_dream_work.gif)

우리는 다른 팀의 작업에 의존했습니다. 따라서 그들과 좋은 관계를 유지하는 것도 개발 과정에서 중요한 포인트였습니다.

소통이 핵심이었습니다. 소통할수록 우리는 더 발전했습니다. 덕분에, 우리의 목표는 한 팀이 되는 것이었습니다. 다음은 이러한 커뮤니케이션을 개선하기 위해 수행한 몇 가지 작업입니다.

- 우리만을 위한 개인적인 장소를 가져라. 별도의 채널을 만들어 진행상황에 대해 이야기하고, 별도의 회의 없이 질문이나 의구심을 조속히 해소했습니다.
- 빠른 회의. 주 1회 회의가 주요 쟁점들에 대한 진행 상황을 점검하는 데 큰 도움이 되었다. 그러나 우리는 항상 이 회의를 기다리지 않았고, 문제가 논의될 때마다 짧은 통화를 했습니다.
- 전반적인 진행 상황에 대한 최신 정보를 유지합니다. 우리 팀의 팀 동료가 그들의 일일 스탠드업에 참석했고 그들 중 한 명은 필요할 경우 팀의 나머지를 업데이트했다.

다음은 NAT과 Integration 팀의 실제 모습입니다.

![image](https://www.freecodecamp.org/news/content/images/2020/12/source--1-.gif)

첫 번째 MVP가 시작될 때는 단서가 너무 많고 명확하게 하기에는 소통이 너무 부족해서 가끔 막히거나 이런 이슈들에 대해서 시간 낭비를 하는 모임을 마련해야 했다.

삶의 대부분의 문제들과 마찬가지로 문제의 핵심은 의사소통의 부족이었다. 그래서 우리는 커뮤니케이션을 강화하고, 고객에게 직접 질문을 하고, 그들이 필요하지 않은 경우에도 회고전, 매일의 스탠드업, 기타 미팅에 초대함으로써 해결했습니다.

이 덕분에 클라이언트는 가능한 한 업데이트 상태를 유지할 수 있었습니다. 결국, 우리는 소통할수록 더 많은 것을 그들에게 느끼게 했고, 우리가 함께 더 잘 일하게 했습니다.

## 마지막 생각

먼저 팀원들에게 감사 인사를 드리고 싶습니다. 프로젝트를 함께 발전시켜 나가며 함께 즐거운 시간을 보내고자 하는 하루하루를 시작하며 그들과 함께 일하는 것은 즐거움이었다.

같은 차원에서 요청 시 항상 도움의 손길을 내민 다른 팀 동료들에게 감사드린다.

이렇게 많은 것을 알게 된 프로젝트의 완벽한 구현에 참여할 수 있는 기회도 감사하게 생각합니다. 환경 설정, 파이프라인, 서비스 간 메시징, 데이터 지속 및 검색, 프런트 엔드 제공, 인터페이스 구현 등의 Front, Back 및 DevOps 관련 문제를 해결했습니다.

마지막으로, GraphQL이나 TypeScript와 같은 사이드 프로젝트에서 사용하던 기술을 더 잘 사용하고 일할 수 있는 기회를 갖게 되어 감사합니다.

이 기사 잘 보셨기를 바랍니다. 내 사이트에서도 다른 사람들과 함께 읽을 수 있어! 일반적으로 질문, 제안 또는 피드백이 있다면 주저하지 말고 제 사이트에서 소셜 네트워크에 연락하십시오.